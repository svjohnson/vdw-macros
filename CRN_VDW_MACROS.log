1                                                          The SAS System                            06:31 Tuesday, November 8, 2005

NOTE: Unable to open SASUSER.REGSTRY. WORK.REGSTRY will be opened instead.
NOTE: All registry changes will be lost at the end of the session.

NOTE: Copyright (c) 2002-2003 by SAS Institute Inc., Cary, NC, USA. 
NOTE: SAS (r) 9.1 (TS1M3)
      Licensed to GROUP HEALTH COOPERATIVE OF PUGET SOUND, Site 0009688001.
NOTE: This session is executing on the XP_PRO  platform.



NOTE: This installation is running SAS/STAT hot fix bundle SAS 9.1.3 Service Pack 2.

NOTE: SAS initialization used:
      real time           9.23 seconds
      cpu time            1.42 seconds
      
1          /*********************************************
2          * Roy Pardee
3          * Center For Health Studies
4          * (206) 287-2078
5          * pardee.r@ghc.org
6          *
7          * \\groups\data\CTRHS\Crn\S D R C\VDW\Macros\CRN_VDW_MACROS.sas
8          *
9          * Contains standard VDW macros for use against VDW data.
10         *********************************************/
11         
12         * Utility macro for fairly precisely calculating age. ;
13         %macro CalcAge(BDtVar, RefDate) ;
14            intck('YEAR', &BDtVar, &RefDate) -
15            (mdy(month(&RefDate), Day(&RefDate), 2004) <
16             mdy(month(&BDtVar) , day(&BDtVar) , 2004))
17         %mend CalcAge ;
18         
19         %macro GetRxForPeople(People     /* The name of a dataset containing the MRNs of
19       ! people whose fills you want. */
20                             , StartDt    /* The date on which you want to start collecting
20       ! fills. */
21                             , EndDt      /* The date on which you want to stop collecting
21       ! fills. */
22                             , Outset     /* The name of the output dataset containing the
22       ! fills. */) ;
23         
24            /*
25               Gets the pharmacy fills for a specified set of people (identified by MRNs)
26               which ocurred between the dates specified in StartDt and EndDt.
27            */
28            libname __rx "&_RxLib." access = readonly ;
29         
30            %if &People = &Outset %then %do ;
31               %put PROBLEM: The People dataset must be different from the OutSet dataset. ;
32               %put PROBLEM: Both parameters are set to "&People". ;
33               %put PROBLEM: Doing nothing. ;
2                                        The SAS System          06:31 Tuesday, November 8, 2005

34            %end ;
35            %else %do ;
36               proc sql ;
37                  create table &OutSet as
38                  select r.*
39                  from __rx.&_RxData as r INNER JOIN
40                        &People as p
41                  on    r.MRN = p.MRN
42                  where r.RxDate BETWEEN "&StartDt"d AND "&EndDt"d ;
43               quit ;
44            %end ;
45            libname __rx clear;
46         %mend GetRxForPeople ;
47         /*********************************************************;
48         * Testing GetRxForPeople (tested Ok 20041230 gh);
49         * ;
50         %include '\\Groups\data\CTRHS\Crn\S D R C\VDW\Macros\StdVars.sas';
51         
52         data PeopleIn;
53           infile '\\Groups\data\CTRHS\Crn\S D R C\VDW\Macros\testchs100.txt';
54           input mrn $char10.;
55         run;
56         
57         %GetRxForPeople(PeopleIn,01Jan2002,31Dec2002,RxOut) ;
58         **********************************************************/;
59         
60         
61         %macro GetRxForDrugs(DrugLst     /* The name of a dataset containing the NDCs of the
61       ! drugs whose fills you want. */
62                             , StartDt    /* The date on which you want to start collecting
62       ! fills. */
63                             , EndDt      /* The date on which you want to stop collecting
63       ! fills. */
64                             , Outset     /* The name of the output dataset containing the
64       ! fills. */) ;
65         
66            /*
67               Gets the pharmacy fills for a specified set of drugs (identified by NDCs)
68               which ocurred between the dates specified in StartDt and EndDt.
69            */
70         
71            %if &DrugLst = &Outset %then %do ;
72               %put PROBLEM: The Drug List dataset must be different from the OutSet dataset.
72       ! ;
73               %put PROBLEM: Both parameters are set to "&DrugLst". ;
74               %put PROBLEM: Doing nothing. ;
75            %end ;
76            %else %do ;
77               libname __rx "&_RxLib" access = readonly ;
78               proc sql ;
79                  create table &OutSet as
80                  select r.*
81                  from __rx.&_RxData as r INNER JOIN
3                                        The SAS System          06:31 Tuesday, November 8, 2005

82                        &DrugLst as p
83                  on    r.NDC = p.NDC
84                  where r.RxDate BETWEEN "&StartDt"d AND "&EndDt"d ;
85               quit ;
86               libname __rx clear ;
87            %end ;
88         %mend GetRxForDrugs ;
89         %macro GetRxForPeopleAndDrugs(People       /* The name of a dataset containing the
89       ! people whose fills you want. */
90                            					 	, DrugLst    /* The NDC codes of interest */
91                             					, StartDt    /* The date on which you want to start
91       ! collecting fills. */
92                             					, EndDt      /* The date on which you want to stop
92       ! collecting fills. */
93                             					, Outset     /* The name of the output dataset containing
93       ! the fills. */) ;
94         
95            /*
96               Gets the pharmacy fills for a specified set of people (identified by MRNs)
97               which occurred between the dates specified in StartDt and EndDt.
98            */
99         
100           %if &People = &Outset %then %do ;
101              %put PROBLEM: The People dataset must be different from the OutSet dataset. ;
102              %put PROBLEM: Both parameters are set to "&People". ;
103              %put PROBLEM: Doing nothing. ;
104           %end ;
105           %else %do ;
106              proc sql ;
107          	    create table &OutSet as
108        	  			select r.*
109           				from  rx.&_Rxdata as r
110           				INNER JOIN &People as p
111           				on    r.MRN = p.MRN
112           				where r.RxDate BETWEEN "&StartDt"d AND "&EndDt"d AND
113                 				r.NDC in (select NDC from &DrugLst) ;
114              quit ;
115           %end ;
116        %mend GetRxForPeopleAndDrugs ;
117        
118        %macro GetDxForPeopleAndDx (People       /* The name of a dataset containing the
118      ! people whose fills you want. */
119                           					 	, DxLst    /* The ICD9 codes of interest */
120                            					, StartDt    /* The date on which you want to start
120      ! collecting fills. */
121                            					, EndDt      /* The date on which you want to stop
121      ! collecting fills. */
122                            					, Outset     /* The name of the output dataset containing
122      ! the fills. */) ;
123           %if &People = &Outset %then %do ;
124              %put PROBLEM: The People dataset must be different from the OutSet dataset. ;
125              %put PROBLEM: Both parameters are set to "&People". ;
126              %put PROBLEM: Doing nothing. ;
4                                        The SAS System          06:31 Tuesday, November 8, 2005

127           %end ;
128           %else %do ;
129              proc sql ;
130                create table &OutSet as
131        			  select d.*
132           			from  util.&_dxdata as d
133           			INNER JOIN &People as p
134           			on    d.MRN = p.MRN
135           			where d.ADate BETWEEN "&StartDt"d AND "&EndDt"d AND
136           						d.dx in (select dx from &DxLst) ;
137                ;
138              quit ;
139           %end ;
140        
141        %mend GetDxForPeopleAndDx;
142        %macro CountFills(DrugList) ;
143           /*
144              Counts the number of fills for each of the NDC codes specified in
145              the input dataset.
146           */
147        
148           libname __rx "&_RxLib" access = readonly ;
149        
150           proc sql ;
151              title2 "Extent of pharmacy data." ;
152              select count(*) as NumFills label = "Total rx records"
153                    , min(RxDate) as FirstFill format = mmddyy10. label = "Earliest recorded
153      ! fill"
154                    , max(RxDate) as LastFill format = mmddyy10. label = "Most recent
154      ! recorded fill"
155              from __rx.&_RxData ;
156        
157              title2 "Number of fills for the list of NDCs in &DrugList" ;
158              select d.generic
159                    , d.NDC
160                    , count(r.NDC) as NumFills label = "Number of Fills"
161                    , min(r.RxDate) as FirstFill format = mmddyy10. label = "Date of first
161      ! fill"
162                    , max(r.RxDate) as LastFill format = mmddyy10. label = "Date of most
162      ! recent fill"
163              from  &DrugList as d LEFT JOIN
164                    __rx.&_RxData as r
165              on    d.NDC = r.NDC
166              group by d.generic, d.NDC ;
167           quit ;
168        
169           libname __rx clear ;
170        %mend CountFills ;
171        
172        %macro BreastCancerDefinition01(StartDt = 01Jan1997
173                                      , EndDt = 31Dec2003
174                                      , OutSet = brca) ;
175           /*
5                                        The SAS System          06:31 Tuesday, November 8, 2005

176              Pulls the set of "incident" (that is, first-ocurring during the specified date
176      ! range)
177              breast cancers, both invasive and in-situ (but excluding LCIS).
178        
179              These criteria are based on the ones used for the Early Screening study.
180              See:
180      ! https://www.kpchr.org/CRN2/apps/storage/docs/20000823whmesprogramming_case_criteria.d
180      ! oc.
181           */
182        
183           libname __tum "&_TumorLib" access = readonly ;
184        
185           proc sql number ;
186              create table _AllBreastTumors as
187              select mrn
188                    , DxDate
189                    , DtMrk1 as ERMarker
190                    , StageGen
191                    , StageAJ
192              from  __tum.&_TumorData
193              where DxDate between "&StartDt"d and "&EndDt"d  AND
194                    ICDOSite between 'C500' and 'C509'        AND
195                    Gender = '2'                              AND
196                    Morph NOT between '9590' and '9979'       AND
197                    ( (behav in ('3', '6', '9')) OR
198                      (behav = '2' AND MORPH ne '8520')) ;
199        
200              create table _FirstBTs as
201              select DISTINCT b.*
202              from  _AllBreastTumors as b INNER JOIN
203                    (select MRN, min(DxDate) as FirstBTDate from _AllBreastTumors group by
203      ! MRN) as b2
204              on    b.MRN = b2.MRN AND
205                    b.DxDate = b2.FirstBTDate
206              order by mrn, ERMarker ;
207        
208              drop table _AllBreastTumors ;
209        
210              title "These people had >1 tumor dxd on the same day, each with different
210      ! receptor statuses or stages." ;
211              select *
212              from  _FirstBTs
213              where MRN in (select MRN from _FirstBTs group by MRN having count(*) > 1) ;
214              title ;
215        
216              * Some women will have > 1 breast tumor dxd on the same day, each with ;
217              * different stages and/or receptor statuses.  We want to call the receptor
217      ! status ;
218              * positive if any tumor is positive, and we want to take the greatest stage. ;
219        
220              create table &OutSet as
221              select mrn
222                    , dxdate
6                                        The SAS System          06:31 Tuesday, November 8, 2005

223                    , min(case ERMarker
224                             when '0' then 10
225                             else input(ERMarker, 2.0)
226                          end) as ERMarker format = ERM.
227                    , max(case lowcase(StageGen)
228                             when '9' then -1
229                             when 'b' then -2
230                             else input(StageGen, 2.0)
231                          end) as StageGen format = StageGen.
232                    , max(case lowcase(StageAJ)
233                             when '' then -1
234                             when 'unk' then -1
235                             when '2a' then 2
236                             when '2b' then 2.5
237                             when '3a' then 3
238                             when '3b' then 3.5
239                             else input(StageAJ, 2.0)
240                          end) as StageAJ format = StageAJ.
241              from _FirstBTs
242              group by mrn, dxdate ;
243           quit ;
244        
245           libname __tum clear ;
246        
247        %mend BreastCancerDefinition01 ;
248        
249        *************************************************************************************
249      ! **********;
250        * MACRO: PULLCONTINUOUS
250      !           ;
251        * VARIABLES NECESSARY TO PROVIDE:
251      !           ;
252        *
252      !           ;
253        * PLUGIN     * DATASET WITH 2 VARIABLES: MRN, INDEXDT=INDEX/DIAGNOSIS DATE
253      !           ;
254        * PRETIME    * CONTINUOUS MONTHS OF MEMBERSHIP PRIOR TO INDEX DT REQUIRED (DEFAULT=0)
254      !           ;
255        * PREGAP     * NUMBER OF MONTHS DISENROLLMENT ALLOWED PRIOR TO INDEX DT (DEFAULT=0
255      ! CUMULATIVE) ;
256        * POSTIME    * CONTINUOUS MONTHS OF MEMBERSHIP AFTER INDEX DT REQUIRED (DEFAULT=0)
256      !           ;
257        * POSTGAP    * NUMBER OF MONTHS DISENROLLMENT ALLOWED AFTER INDEX DT (DEFAULT=0
257      ! CUMULATIVE)    ;
258        *
258      !           ;
259        * TO CALL:    PULLCONTINUOUS(PLUGIN,PRETIME,PREGAP,POSTIME=0,POSTGAP=0)
259      !           ;
260        *************************************************************************************
260      ! **********;
261        
262        %MACRO PULLCONTINUOUS(PLUGIN,PRETIME=0,PREGAP=0,POSTIME=0,POSTGAP=0);
263        
7                                        The SAS System          06:31 Tuesday, November 8, 2005

264        %PUT PLUGIN=&PLUGIN PRETIME=&PRETIME PREGAP=&PREGAP
265        POSTIME=&POSTIME POSTGAP=&POSTGAP;
266        
267        /*** CREATE MARKERS FOR MONTH MATRIX */
268        TITLE "TO PULL SAMPLE WITH &PRETIME CONTINUOUS MONTHS MEMBERSHIP PRE DX DATE (&PREGAP
268      !  MONTH GAP)";
269        TITLE2 "&POSTIME CONTINUOUS MONTHS MEMBERSHIP POST DX DATE (&POSTGAP MONTH GAP)";;
270        DATA DATEX;
271             SET &PLUGIN;
272             INDEXMON = MONTH(INDEXDT);
273             INDEXYR = YEAR(INDEXDT);
274             MATRXIND = (CEIL(&PRETIME/12) *12) + MONTH(INDEXDT);
275             MATRXPRE = MATRXIND-&PRETIME;
276             MATRXPOST = MATRXIND+&POSTIME;
277             PREDTMON = MATRXPRE-((FLOOR(MATRXPRE/12))*12);
278             IF PREDTMON = 0 THEN PREDTMON = 12;
279             PREDTYR= INDEXYR-(CEIL(&PRETIME/12));
280             POSTDTMON = MATRXPOST-((FLOOR(MATRXPOST/12))*12);
281             IF POSTDTMON = 0 THEN POSTDTMON = 12;
282             POSTDTYR = INDEXYR+(FLOOR(&POSTIME/12));
283        PROC PRINT DATA = DATEX (OBS=30 DROP= MRN);
284        RUN;
285        
286        /*** GET DATA FOR EACH CASE BOUNDED BY INDEX MARKERS */
287        libname enrol "&_EnrollLib." access=readonly;
288        PROC SQL;
289             CREATE TABLE TESTDATA AS
290             SELECT  DATEX.POSTDTMON, DATEX.POSTDTYR, DATEX.PREDTYR, DATEX.PREDTMON,
291                  ENR.MRN, ENR.ENR_MONTH, ENR.ENR_YEAR,
292                  1 AS ANCHOR
293             FROM DATEX, enrol.&_EnrollData AS ENR
294             WHERE (((ENR_YEAR = PREDTYR) AND (ENR_MONTH >= PREDTMON))
295                  OR
296                    ((ENR_YEAR = POSTDTYR) AND (ENR_MONTH <= POSTDTMON))
297                  OR
298                  (PREDTYR < ENR_YEAR < POSTDTYR))
299                  AND (ENR.MRN=DATEX.MRN);
300             QUIT;
301        
302        TITLE 'MAX # MONTHS IN MATRIX';
303        PROC SQL;
304             SELECT MAX(MATRXPOST)
305             INTO :MONMAX
306             FROM DATEX;
307             QUIT;
308        %LET MONMAX=&MONMAX;
309        %PUT MONMAX= &MONMAX;
310        
311        PROC PRINT DATA = TESTDATA (OBS=100 DROP = MRN);
312        TITLE 'TESTDATA';
313        RUN;
314        
315        DATA TESTDATA (KEEP=MRN MON ANCHOR);
8                                        The SAS System          06:31 Tuesday, November 8, 2005

316             SET TESTDATA (KEEP=MRN ENR_MONTH ENR_YEAR PREDTYR ANCHOR);
317        MON = TRIM('E'||LEFT(((ENR_YEAR-PREDTYR)*12)+ENR_MONTH));
318        
319        PROC PRINT DATA = TESTDATA (OBS=30 DROP = MRN);
320        TITLE 'TESTDATA';
321        RUN;
322        
323        PROC FREQ DATA = TESTDATA;
324        TABLES MON;RUN;
325        
326        PROC SORT DATA  = TESTDATA;
327         BY MRN;
328        
329        /*** CREATE ARRAY OF MEMBER MONTHS INDEXED TO MONTH MATRIX */
330        PROC TRANSPOSE DATA = TESTDATA OUT = T2 NAME =TEMP;
331             BY MRN;
332             ID  MON;
333             IDLABEL MON;
334             VAR ANCHOR;
335             RUN;
336        
337        proc print data= t2 (obs=30 DROP = MRN);
338             run;
339        
340        /*** MERGE ARRAY AND MATRIX MARKERS */
341        PROC SQL;
342             CREATE TABLE T3 AS
343             SELECT T2.*,DATEX.*
344             FROM T2,DATEX
345             WHERE T2.MRN=DATEX.MRN;
346             QUIT;
347        
348        
349        TITLE 'SAMPLE BEFORE ARRAY LOOKUP';RUN;
350        
351        /*** DETERMINE CONTINOUS MEMBERSHIP AND GAPS : OUTPUT SELECTED CASES AND EXCLUDED */
352        DATA SELECTED EXCLUDED;
353             SET T3;
354        ARRAY ENRX (*) E1-E&MONMAX;
355        KTRPRE = 0; KTRPOST = 0;
356        GAPPRE = 0; GAPPOST =0;
357        DO I = MATRXPRE TO MATRXPOST ;
358          IF (I < MATRXIND) AND (ENRX(I) = 1) THEN KTRPRE + 1;
359             ELSE IF (I < MATRXIND) AND (ENRX(I) = .) THEN GAPPRE+1;
360          IF (&POSTIME>0) THEN DO;
361             IF (MATRXIND < I <= MATRXPOST) AND (ENRX(I) = 1) THEN KTRPOST + 1;
362             ELSE IF (MATRXIND < I <= MATRXPOST) AND (ENRX(I) = .) THEN GAPPOST + 1;
363          END;
364        *PUT MRN 'ENRX(I)=' ENRX(I) 'I=' I 'MATRXIND=' MATRXIND 'KTRPRE=' KTRPRE 'GAPPRE='
364      ! GAPPRE 'GAPPOST=' GAPPOST;
365        END;
366        IF (KTRPRE >= (&PRETIME-&PREGAP) AND KTRPOST >= (&POSTIME-&POSTGAP)) THEN OUTPUT
366      ! SELECTED;
9                                        The SAS System          06:31 Tuesday, November 8, 2005

367        ELSE OUTPUT EXCLUDED;
368        RUN;
369        
370        TITLE "MEMBERS WITH &PRETIME CONTINUOUS MONTHS MEMBERSHIP PRE DX DATE (&PREGAP MONTH
370      ! GAP)";
371        TITLE2 "&POSTIME CONTINUOUS MONTHS MEMBERSHIP POST DX DATE (&POSTGAP MONTH GAP)";;
372        
373        PROC SQL;
374             SELECT COUNT(*) AS TOTAL_SELECTED
375             FROM SELECTED;
376             QUIT;
377        
378        Proc print data= SELECTED (obs=30);
379             VAR E1-E&MONMAX INDEXDT MATRXPRE MATRXIND MATRXPOST KTRPRE GAPPRE KTRPOST
379      ! GAPPOST;
380             run;
381        
382        PROC FREQ DATA = SELECTED;
383             TABLES GAPPRE GAPPOST;
384             RUN;
385        
386        PROC FREQ DATA = EXCLUDED;
387             TABLES KTRPRE*GAPPRE KTRPOST*GAPPOST/LIST;
388             TITLE 'EXCLUDED CASES';
389             RUN;
390        
391        %MEND PULLCONTINUOUS;
392        
393        %macro ndclookup(inds     /* An input dataset of strings to search for, in a var
393      ! named "drugname".  */
394                       , outds    /* The name of the output dset of NDCs, which contain one
394      ! of the input strings. */
395                       , EverNDC  /* The name of your local copy of the EverNDC file. */
396                       );
397        
398        **********************************************************************************;
399        * look up NDC codes by drugnames or fragments of drugnames
400        * Check the results file to see that they are all drugs of interest
401        *
402        * Input:
403        *	inds is the name of the input SAS dataset with the list of character strings to
403      ! match
404        *		contains the variable "drugname"
405        *		Both the Generic and Brand fields are searched for all input strings
406        *
407        *	outds is the name of the output SAS dataset
408        *       EverNDC is the SAS dataset name of the file of all NDCcodes
409        *
410        *  EverNDC is the fully qualified name of your local copy of the EverNDC dataset.
411        *
412        *    Example:
413        *Data StringsOfInterest;
414        *   input  drugname $char20.;
10                                       The SAS System          06:31 Tuesday, November 8, 2005

415        *   datalines;
416        *TAMOX
417        *Ralox
418        *NOLVADEX
419        *LETROZOLE
420        *EXEMESTANE
421        *ANASTROZOLE
422        
423        *%ndclookup(StringsOfInterest, NDCs_of_Interest, mylib.EverNDC);
424        ***********************************************************************************;
425        
426           proc sql noprint ;
427        
428              * Create a monster WHERE clause to apply to ever_ndc from the contents of InDs.
428      !  ;
429              * The embedded single quotes can get a bit confusing--just remember that ;
430              * one single quote character escapes the following one.  So a string of four
430      ! single-quote ;
431              * chars in a row defines a string containing one single quote--the two on the
431      ! ends delimit ;
432              * the string, and the two in the middle resolve to one (the first one escaping
432      ! the second). ;
433              * SQL written by Roy Pardee
433      !              ;
434        
435              select      'upcase(n.Generic) LIKE ''%' || trim(upcase(s.DrugName))|| '%''' ||
435      !  ' OR
436                           upcase(n.Brand)   LIKE ''%' || trim(upcase(s.DrugName))|| '%''' as
436      !  where_clause
437              into :wh separated by ' OR '
438              from &inds as s ;
439        
440              * First pull all of the NDCs that meet the WHERE clause above. ;
441              create table _OfInterest as
442              select distinct *
443              from &everndc as n
444              where &wh ;
445        
446              * Now pull drugs that *dont* match the WHERE clause, but share an NDC with one
446      ! that does. ;
447              create table _Suspicious as
448              select distinct n.*
449              from _OfInterest as a inner join &everndc as n
450              on a.ndc = n.ndc
451              where not (&wh)
452              ;
453        
454              * Mash the two dsets together ;
455              create table &outds as
456              select *, 0 as Suspicious label = "Flag indicating whether Generic or Brand
456      ! contained a string of interest."
457              from _OfInterest
458              UNION ALL
11                                       The SAS System          06:31 Tuesday, November 8, 2005

459              select *, 1 as Suspicious
460              from _Suspicious ;
461        
462              drop table _OfInterest ;
463              drop table _Suspicious ;
464           quit ;
465        %mend ndclookup;
466        
467        %macro GetPxForPeople(People     /* The name of a dataset containing the people whose
467      !  procedures you want. */
468                            , StartDt    /* The date on which you want to start collecting
468      ! procedures. */
469                            , EndDt      /* The date on which you want to stop collecting
469      ! procedures. */
470                            , Outset     /* The name of the output dataset containing the
470      ! procedures. */) ;
471        
472           /*
473              Gets the procedures for a specified set of people (identified by MRNs)
474              which ocurred between the dates specified in StartDt and EndDt.
475           */
476           libname __util "&_UtilizationLib" access = readonly ;
477        
478           %if &People = &Outset %then %do ;
479              %put PROBLEM: The People dataset must be different from the OutSet dataset. ;
480              %put PROBLEM: Both parameters are set to "&People". ;
481              %put PROBLEM: Doing nothing. ;
482           %end ;
483           %else %do ;
484              proc sql ;
485                 create table &OutSet as
486                 select r.*
487                 from __util.&_PxData as r INNER JOIN
488                       &People as p
489                 on    r.MRN = p.MRN
490                 where r.ADate BETWEEN "&StartDt"d AND "&EndDt"d ;
491              quit ;
492           %end ;
493           libname __util clear ;
494        %mend GetPxForPeople ;
495        
496        %macro GetUtilizationForPeople(People     /* The name of a dataset containing the
496      ! people whose procedures you want. */
497                                     , StartDt    /* The date on which you want to start
497      ! collecting procedures. */
498                                     , EndDt      /* The date on which you want to stop
498      ! collecting procedures. */
499                                     , Outset     /* The name of the output dataset
499      ! containing the procedures. */) ;
500        
501           /*
502              Gets the utilization records for a specified set of people (identified by MRNs)
503              which ocurred between the dates specified in StartDt and EndDt.
12                                       The SAS System          06:31 Tuesday, November 8, 2005

504           */
505           libname __util "&_UtilizationLib" access = readonly ;
506        
507           %if &People = &Outset %then %do ;
508              %put PROBLEM: The People dataset must be different from the OutSet dataset. ;
509              %put PROBLEM: Both parameters are set to "&People". ;
510              %put PROBLEM: Doing nothing. ;
511           %end ;
512           %else %do ;
513              proc sql ;
514                 create table &OutSet as
515                 select r.*
516                 from __util.&_UtilizationData as r INNER JOIN
517                       &People as p
518                 on    r.MRN = p.MRN
519                 where r.ADate BETWEEN "&StartDt"d AND "&EndDt"d ;
520              quit ;
521           %end ;
522           libname __util clear ;
523        %mend GetUtilizationForPeople ;
524        
525        /*********************************************************;
526        * Testing GetPxForPeople (tested ok 20041230 gh);
527        * ;
528        %include '\\Groups\data\CTRHS\Crn\S D R C\VDW\Macros\StdVars.sas';
529        
530        data PeopleIn;
531          infile '\\Groups\data\CTRHS\Crn\S D R C\VDW\Macros\testchs100.txt';
532          input mrn $char10.;
533        run;
534        
535        %GetPxForPeople(PeopleIn,01Jan2002,31Dec2002,PxOut) ;
536        **********************************************************/;
537        
538        %macro GetDxForPeople(People     /* The name of a dataset containing the people whose
538      !  diagnoses you want. */
539                            , StartDt    /* The date on which you want to start collecting
539      ! diagnoses. */
540                            , EndDt      /* The date on which you want to stop collecting
540      ! diagnoses. */
541                            , Outset     /* The name of the output dataset containing the
541      ! diagnoses. */) ;
542        
543           /*
544              Gets the diagnoses for a specified set of people (identified by MRNs)
545              which ocurred between the dates specified in StartDt and EndDt.
546           */
547           libname __util "&_UtilizationLib" access = readonly ;
548           %if &People = &Outset %then %do ;
549              %put PROBLEM: The People dataset must be different from the OutSet dataset. ;
550              %put PROBLEM: Both parameters are set to "&People". ;
551              %put PROBLEM: Doing nothing. ;
552           %end ;
13                                       The SAS System          06:31 Tuesday, November 8, 2005

553           %else %do ;
554              proc sql ;
555                 create table &OutSet as
556                 select r.*
557                 from __util.&_DxData as r INNER JOIN
558                       &People as p
559                 on    r.MRN = p.MRN
560                 where r.ADate BETWEEN "&StartDt"d AND "&EndDt"d ;
561              quit ;
562           %end ;
563           libname __util clear;
564        %mend GetDxForPeople ;
565        /*********************************************************;
566        * Testing GetDxForPeople (tested ok 20041230 gh);
567        * ;
568        %include '\\Groups\data\CTRHS\Crn\S D R C\VDW\Macros\StdVars.sas';
569        
570        data PeopleIn;
571          infile '\\Groups\data\CTRHS\Crn\S D R C\VDW\Macros\testchs100.txt';
572          input mrn $char10.;
573        run;
574        
575        %GetDxForPeople(PeopleIn,01Jan2002,31Dec2002,DxOut) ;
576        **********************************************************/;
577        
578        
579        %macro GetDxForDx(DxLst     /* The name of a dataset containing the diagnosis list
579      ! you want. */
580                        , DxVarName   /* The name of the DX variable in DxLst  */
581                        , StartDt    /* The date on which you want to start collecting fills.
581      !  */
582                        , EndDt      /* The date on which you want to stop collecting fills.
582      ! */
583                        , Outset     /* The name of the output dataset containing the fills.
583      ! */) ;
584        
585           /*
586              Gets the records for a specified set of diagnoses (identified by ICD9 code)
587              which ocurred between the dates specified in StartDt and EndDt.
588           */
589           libname __util "&_UtilizationLib" access = readonly ;
590           %if &DxLst = &Outset %then %do ;
591              %put PROBLEM: The Diagnosis List dataset must be different from the OutSet
591      ! dataset. ;
592              %put PROBLEM: Both parameters are set to "&DxLst". ;
593              %put PROBLEM: Doing nothing. ;
594           %end ;
595           %else %do ;
596              proc sql ;
597                 create table &OutSet as
598                 select DBig.*
599                 from  __util.&_DxData as DBig INNER JOIN
600                       &DxLst as DLittle
14                                       The SAS System          06:31 Tuesday, November 8, 2005

601                 on    DBIG.DX = Dlittle.&DxVarName.
602                 where Dbig.ADate BETWEEN "&StartDt"d AND "&EndDt"d ;
603              quit ;
604           %end ;
605           libname __util clear;
606        %mend GetDxForDx ;
607        /*********************************************************;
608        * Testing GetDxForDx (tested 20041230 gh);
609        * ;
610        %include '\\Groups\data\CTRHS\Crn\S D R C\VDW\Macros\StdVars.sas';
611        
612        data DxOfInterest;
613          input dx $char6.;
614          cards;
615        V22   Normal pregnancy
616        V22.0       Supervision of normal first pregnancy
617        V22.1       Supervision of other normal pregnancy
618        V22.2       Pregnant state, incidental
619        run;
620        
621        %GetDxForDx(DxOfInterest, dx,01Jan2002,31Dec2002,DxOut) ;
622        **********************************************************/;
623        
624        %macro GetPxForPx(PxLst             /* The name of a dataset containing the procedure
624      !  list you want. */
625                        , PxVarName         /* The name of the Px variable in PxLst  */
626                        , PxCodeTypeVarName /* Px codetype variable name in PxLst  */
627                        , StartDt           /* The date on which you want to start collecting
627      !  data. */
628                        , EndDt             /* The date on which you want to stop collecting
628      ! data. */
629                        , Outset            /* The name of the output dataset containing the
629      ! data. */) ;
630        
631           /*
632              Gets the records for a specified set of diagnoses (identified by ICD9 code)
633              which ocurred between the dates specified in StartDt and EndDt.
634           */
635           libname __util "&_UtilizationLib" access = readonly ;
636           %if &PxLst = &Outset %then %do ;
637              %put PROBLEM: The Px List dataset must be different from the OutSet dataset. ;
638              %put PROBLEM: Both parameters are set to "&PxLst". ;
639              %put PROBLEM: Doing nothing. ;
640           %end ;
641           %else %do ;
642              proc sql ;
643                 create table &OutSet as
644                 select PBig.*
645                 from  __util.&_PxData as PBig INNER JOIN
646                       &PxLst as PLittle
647                 on    PBig.PX = PLittle.&PxVarName.  and
648                       PBig.CodeType = PLittle.&PxCodeTypeVarName.         /* will this screw
648      !  up use of an index? gh */
15                                       The SAS System          06:31 Tuesday, November 8, 2005

649                 where Pbig.ADate BETWEEN "&StartDt"d AND "&EndDt"d ;
650              quit ;
651           %end ;
652           libname __util clear ;
653        %mend GetPxForPx ;
654        *********************************************************;
655        * Testing GetPxForPx (tested 20041230 gh);
656        * ;
657        /*
658        %include '\\Groups\data\CTRHS\Crn\S D R C\VDW\Macros\StdVars.sas';
659        
660        data PxOfInterest;
661          input Px $char6. CodeType $char1.;
662          cards;
663        59409 C VAGINAL DELIVERY ONLY
664        59410 C  VAGINAL DELIVERY INCL POSTPARTUM CARE
665        59510 C  ROUTINE OB CARE INCL ANTEPARTUM CAR, CESAREAN DELIVER, POSTPARTUM CARE
666        59514 C  CESAREAN DELIVERY ONLY
667        run;
668        
669        %GetPxForPx(PxOfInterest, px, CodeType, 01Jan2002,31Dec2002,PxOut) ;
670        **********************************************************;
671        */
672        
673        /* *********************************************************
674        * Takes an input dataset bearing a specified ID code (e.g.,
675        * MRN) and replaces it with an arbitrary
676        * StudyID, creating a crosswalk dset that relate the
677        * original ID codes to the new StudyIDs.
678        *
679        * Sample call:
680        *
681        * %DeIDDset( InSet = phe.people    The input dataset.
682        *          , XWalkSet = phe.xwalk  Name of the crosswalk dset
683        *          , OldIDVar = CHSID      Name of the ID variable you want removed.
684        *          , NewIDVar = StudyID    Name for the new ID variable.
685        *          , NewIDLen = 8          The length of the new ID variable.
686        *          ) ;
687        ********************************************************* */
688        
689        %macro DeIDDset( InSet         /* Name of the dataset you want de-identified. */
690                       , XWalkSet      /* Name of the output ID-crosswalk dset. */
691                       , OldIDVar      /* Name of the ID variable you want removed. */
692                       , NewIDVar      /* Name for the new ID variable the macro creates. */
693                       , NewIDLen      /* The length of the new ID variable.*/
694                       ) ;
695        
696           proc sql ;
697              create table _UIDs as
698              select distinct &OldIDVar
699              from &InSet ;
700           quit ;
701        
16                                       The SAS System          06:31 Tuesday, November 8, 2005

702           %if %length(%trim(&sqlobs)) > &NewIDLen %then %do ;
703              %put ;
704              %put PROBLEM: THE ID LENGTH SPECIFIED IS INSUFFICIENT!!! ;
705              %put ;
706              %put DOING NOTHING!!! ;
707              %put ;
708           %end ;
709           %else %do ;
710        
711              data &XWalkSet(keep = &NewIDVar &OldIDVar) ;
712                 set _UIDs ;
713                 &NewIDVar = put(_N_, z&NewIDLen..0) ;
714              run ;
715        
716              proc sql ;
717                 create table &InSet(drop = &OldIDVar) as
718                 select x.&NewIDVar
719                       , i.*
720                 from  &XWalkSet as x INNER JOIN
721                       &InSet as i
722                 on    x.&OldIDVar = i.&OldIDVar ;
723              quit ;
724           %end ;
725        
726        %mend DeIDDset ;
727        
728        %macro charlson(inputds, IndexDateVarName, outputds, IndexVarName, inpatonly=I,
728      ! malig=N);
729        /*********************************************
730        
731        * Charlson comorbidity macro.sas
732        *
733        * Computes the Deyo version of the Charleson
734        *
735        *
736        *  Programmer
737        *     Hassan Fouayzi
738        *
739        *
740        * Input data required:
741        *
742        *     VDW Utilization files
743        *     Input SAS dataset INPUTDS
744        *        contains the variables MRN, STUDYID, and INDEXDT
745        *        INPATONLY flag - defauts to Inpatient only (I).  Valid values are
745      ! I-inpatient or B-Both inpatient and outpatient
746        *        MALIG flag - Defaults to no(N).  If MALIG is yes (Y) then the weights of
746      ! Metastasis and Malignancy are set to zero.
747        *                     This may be useful in a study of cancer.
748        * Outputs:
749        *     Dataset &outputsd with on record per studyid
750        *     Variables
751        *       MI= "Myocardial Infarction: "
17                                       The SAS System          06:31 Tuesday, November 8, 2005

752        *       CHD= "Congestive heart disease: "
753        *       PVD= "Peripheral vascular disorder: "
754        *       CVD= "Cerebrovascular disease: "
755        *       DEM= "Dementia: "
756        *       CPD= "Chronic pulmonary disease: "
757        *       RHD= "Rheumatologic disease: "
758        *       PUD= "Peptic ulcer disease: "
759        *       MLIVD= "Mild liver disease: "
760        *       DIAB= "Diabetes: "
761        *       DIABC= "Diabetes with chronic complications: "
762        *       PLEGIA= "Hemiplegia or paraplegia: "
763        *       REN= "Renal Disease: "
764        *       MALIGN= "Malignancy, including leukemia and lymphoma: "
765        *       SLIVD= "Moderate or severe liver disease: "
766        *       MST= "Metastatic solid tumor: "
767        *       AIDS= "AIDS: "
768        *       &IndexVarName= "Charlson score: "
769        *
770        *
771        * Dependencies:
772        *
773        *     StdVars.sas--the site-customized list of standard macro variables.
774        *     The DX and PROC files to which stdvars.sas refer
775        *
776        *
777        * Example of use:
778        *     %charlson(testing,oot, Charles, inpatonly=B)
779        *
780        * Notes:
781        *
782        * Version History
783        *
784        *     Written by Hassan Fouayzi starting with source from Rick Krajenta
785        *     Modified into a SAS Macro format          Gene Hart         2005/04/20
786        *     Malig flag implemented                    Gene Hart         2005/05/04
787        *     Add flag to mark thos with no visits      Gene Hart         2005/05/09
788        *     Should the coalesce function be on studyid or mrn?  1 MRN with 2 STUDYIDs could
788      !  happen
789        *
790        *     move then proc codes to a format
791        *
792        * Source publication
793        *     From: Fouayzi, Hassan [mailto:hfouayzi@meyersprimary.org]
794        *     Sent: Wednesday, May 04, 2005 9:07 AM
795        *     Subject: RE: VDW Charlson macro
796        ...
797        *     “Deyo RA, Cherkin DC, Ciol MA. Adapting a clinical comorbidity Index for use
797      ! with
798        *     ICD-9-CM administrative databases. J Clin Epidemiol 1992; 45: 613-619”.
799        *     We added CPT codes and a couple of procedures for Peripheral vascular disorder.
800        *
801        *********************************************/
802        
18                                       The SAS System          06:31 Tuesday, November 8, 2005

803        /**********************************************/
804        /*Define and format diagnosis codes*/
805        /**********************************************/
806        PROC FORMAT;
807           VALUE $ICD9CF
808        /* Myocardial infraction */
809        	"410   "-"410.9 ",
810        	"412   " = "MI"
811        /* Congestive heart disease */
812        	"428   "-"428.9 " = "CHD"
813        /* Peripheral vascular disorder */
814        	"440.20"-"440.24",
815        	"440.31"-"440.32",
816        	"440.8 ",
817        	"440.9 ",
818        	"443.9 ",
819        	"441   "-"441.9 ",
820        	"785.4 ",
821        	"V43.4 ",
822        	"v43.4 " = "PVD"
823        /* Cerebrovascular disease */
824            "430   "-"438   " = "CVD"
825        /* Dementia */
826        	"290   "-"290.9 " = "DEM"
827        /* Chronic pulmonary disease */
828        	"490   "-"496   ",
829        	"500   "-"505   ",
830        	"506.4 " =  "CPD"
831        /* Rheumatologic disease */
832        	"710.0 ",
833            "710.1 ",
834         	"710.4 ",
835            "714.0 "-"714.2 ",
836            "714.81",
837            "725   " = "RHD"
838        /* Peptic ulcer disease */
839        	"531   "-"534.9 " = "PUD"
840        /* Mild liver disease */
841        	"571.2 ",
842        	"571.5 ",
843        	"571.6 ",
844        	"571.4 "-"571.49" = "MLIVD"
845        /* Diabetes */
846        	"250   "-"250.3 ",
847        	"250.7 " = "DIAB"
848        /* Diabetes with chronic complications */
849        	"250.4 "-"250.6 " = "DIABC"
850        /* Hemiplegia or paraplegia */
851        	"344.1 ",
852        	"342   "-"342.9 " = "PLEGIA"
853        /* Renal Disease */
854        	"582   "-"582.9 ",
855        	"583   "-"583.7 ",
19                                       The SAS System          06:31 Tuesday, November 8, 2005

856        	"585   ",
857        	"586   ",
858        	"588   "-"588.9 " = "REN"
859        /*Malignancy, including leukemia and lymphoma */
860        	"140   "-"172.9 ",
861        	"174   "-"195.8 ",
862        	"200   "-"208.9 " = "MALIGN"
863        /* Moderate or severe liver disease */
864        	"572.2 "-"572.8 ",
865        	"456.0   "-"456.21" = "SLIVD"
866        /* Metastatic solid tumor */
867        	"196   "-"199.1 " = "MST"
868        /* AIDS */
869        	"042   "-"044.9 " = "AIDS"
870        /* Other */
871           other   = "other"
872        ;
873        run;
874        
875        * For debugging. ;
876        %let sqlopts = feedback sortmsg stimer ;
877        %*let sqlopts = ;
878        
879        *************************************************************************************
879      ! *********;
880        *subset to the utilization data of interest (add the people with no visits back at
880      ! the end   *;
881        *************************************************************************************
881      ! *********;
882        libname util "&_UtilizationLib." access = readonly ;
883        
884        **********************************************;
885        * implement the Inpatient and Outpatient Flags;
886        ********************************************** ;
887        %if &inpatonly =I %then %let inpatout=('I');
888        %else %if &inpatonly =B %then %let inpatout=('I','A');
889        %else %Put ERROR in Inpatonly flag.  Valid values are I for Inpatient and B for both
889      ! Inpatient and Outpatient;
890        
891        proc sql &sqlopts ;
892        
893           create table _ppl as
894           select MRN, Min(&IndexDateVarName) as &IndexDateVarName format = mmddyy10.
895           from &inputds
896           group by MRN ;
897        
898           %let TotPeople = &SQLOBS ;
899        
900           alter table _ppl add primary key (MRN) ;
901        
902          create table  _DxSubset as
903          select sample.mrn, &IndexDateVarName,adate, put(dx, $icd9cf.)as CodedDx
904          from util.&_DxData as d, _ppl as sample
20                                       The SAS System          06:31 Tuesday, November 8, 2005

905          where d.mrn = sample.mrn and
906                adate between sample.&IndexDateVarName-1 and sample.&IndexDateVarName-365 and
907          	     enctype in &inpatout.
908          ;
909        
910           select count(distinct MRN) as DxPeople format = comma. label = "No. people who had
910      !  any Dxs w/in a year prior to &IndexDateVarName"
911                 , (CALCULATED DxPeople / &TotPeople) as PercentWithDx format = percent6.2
911      ! label = "Percent of total"
912           from _DxSubset ;
913        
914          create table _PxSubset as
915          select p.*
916          from util.&_PxData as p, _ppl as sample
917          where p.mrn = sample.mrn and
918                adate between sample.&IndexDateVarName-1 and sample.&IndexDateVarName-365 and
919          	     enctype in &inpatout.
920          ;
921        
922           select count(distinct MRN) as PxPeople format = comma. label = "No. people who had
922      !  any Pxs w/in a year prior to &IndexDateVarName"
923                 , (CALCULATED PxPeople / &TotPeople) as PercentWithPx format = percent6.2
923      ! label = "Percent of total sample"
924           from _PxSubset ;
925        
926        quit ;
927        
928        proc sort data = _DxSubset ;
929           by MRN ;
930        run ;
931        
932        proc sort data = _PxSubset ;
933           by MRN ;
934        run ;
935        
936        /**********************************************/
937        /*** Assing DX based flagsts                ***/
938        /***                                        ***/
939        /***                                        ***/
940        /**********************************************/
941        
942        %let var_list = MI CHD PVD CVD DEM CPD RHD PUD MLIVD DIAB DIABC PLEGIA REN MALIGN
942      ! SLIVD MST AIDS ;
943        
944        data _DxAssign ;
945        array COMORB (*) &var_list ;
946        
947        length           &var_list 3 ; *<-- This is host-specific--are we sure we want to do
947      ! this? ;
948        
949        retain           &var_list ;
950        keep   mrn  &var_list ;
951        set _DxSubset;
21                                       The SAS System          06:31 Tuesday, November 8, 2005

952        by mrn;
953        if first.mrn then do;
954           do I=1 to dim(COMORB);
955              COMORB(I) = 0 ;
956           end;
957        end;
958        select (CodedDx);
959           when ('MI')    MI     = 1;
960           when ('CHD')   CHD    = 1;
961           when ('PVD')   PVD    = 1;
962           when ('CVD')   CVD    = 1;
963           when ('DEM')   DEM    = 1;
964           when ('CPD')   CPD    = 1;
965           when ('RHD')   RHD    = 1;
966           when ('PUD')   PUD    = 1;
967           when ('MLIVD') MLIVD  = 1;
968           when ('DIAB')  DIAB   = 1;
969           when ('DIABC') DIABC  = 1;
970           when ('PLEGIA')PLEGIA = 1;
971           when ('REN')   REN    = 1;
972           when ('MALIGN')MALIGN = 1;
973           when ('SLIVD') SLIVD  = 1;
974           when ('MST')   MST    = 1;
975           when ('AIDS')  AIDS   = 1;
976           otherwise ;
977        end;
978        if last.mrn then output;
979        run;
980        
981        /** Procedures: Peripheral vascular disorder **/
982        data _PxAssign;
983           set _PxSubset;
984           by mrn;
985           keep mrn PVD;
986           if first.mrn then PVD = 0;
987           if    PX= "38.48" or
988                 PX ="93668" or
989                 PX in ("34201","34203","35454","35456","35459","35470") or
990                        "35355" <= PX <= "35381" or
991                 PX in ("35473","35474","35482","35483","35485","35492","35493",
992                        "35495","75962","75992") or
993                 PX in ("35521","35533","35541","35546","35548","35549","35551",
994                        "35556","35558","35563","35565","35566","35571","35582","35583",
995                        "35584","35585","35586","35587","35621","35623","35641","35646",
996                        "35647","35651","35654","35656","35661","35663","35665","35666","3567
996      ! 1")
997                 then PVD=1;
998           if last.mrn then output;
999        run;
1000       
1001       /** Connect DXs and PROCs together  **/
1002       proc sql &sqlopts ;
1003         create table _DxPxAssign as
22                                       The SAS System          06:31 Tuesday, November 8, 2005

1004          select  coalesce(D.MRN, P.MRN) as MRN
1005                , D.MI
1006                , D.CHD
1007                , max(D.PVD, P.PVD) as PVD
1008                , D.CVD
1009                , D.DEM
1010                , D.CPD
1011                , D.RHD
1012                , D.PUD
1013                , D.MLIVD
1014                , D.DIAB
1015                , D.DIABC
1016                , D.PLEGIA
1017                , D.REN
1018                , D.MALIGN
1019                , D.SLIVD
1020                , D.MST
1021                , D.AIDS
1022          from  WORK._DXASSIGN as D full outer join
1023                WORK._PXASSIGN P
1024          on    D.MRN = P.MRN
1025          ;
1026       quit ;
1027       
1028       *****************************************************;
1029       * Assign the weights and compute the index
1030       *****************************************************;
1031       
1032       Data _WithCharlson;
1033         set _DxPxAssign;
1034         M1=1;M2=1;M3=1;
1035       
1036       * implement the MALIG flag;
1037          %if &malig =N %then %do; O1=1;O2=1; %end;
1038          %else %if &malig =Y %then  %do; O1=0; O2=0; %end;
1039          %else %Put ERROR in MALIG flag.  Valid values are Y (Cancer study. Zero weight the
1039     !  cancer vars)  and N (treat cancer normally);
1040       
1041         if SLIVD=1 then M1=0;
1042         if DIABC=1 then M2=0;
1043         if MST=1 then M3=0;
1044       
1045       &IndexVarName =   MI + CHD + PVD + CVD + DEM + CPD + RHD +
1046                         PUD + M1*MLIVD + M2*DIAB + 2*DIABC + 2*PLEGIA + 2*REN +
1047                         O1*2*M3*MALIGN + 3*SLIVD + O2*6*MST + 6*AIDS;
1048       
1049       Label
1050       MI= "Myocardial Infarction: "
1051       CHD= "Congestive heart disease: "
1052       PVD= "Peripheral vascular disorder: "
1053       CVD= "Cerebrovascular disease: "
1054       DEM= "Dementia: "
1055       CPD= "Chronic pulmonary disease: "
23                                       The SAS System          06:31 Tuesday, November 8, 2005

1056       RHD= "Rheumatologic disease: "
1057       PUD= "Peptic ulcer disease: "
1058       MLIVD= "Mild liver disease: "
1059       DIAB= "Diabetes: "
1060       DIABC= "Diabetes with chronic complications: "
1061       PLEGIA= "Hemiplegia or paraplegia: "
1062       REN= "Renal Disease: "
1063       MALIGN= "Malignancy, including leukemia and lymphoma: "
1064       SLIVD= "Moderate or severe liver disease: "
1065       MST= "Metastatic solid tumor: "
1066       AIDS= "AIDS: "
1067       &IndexVarName= "Charlson score: "
1068       ;
1069       
1070       keep MRN &var_list &IndexVarName ;
1071       
1072       run;
1073       
1074       /* add the people with no visits back in, and create the final dataset */
1075       /* people with no visits or no comorbidity DXs have all vars set to zero */
1076       
1077       proc sql &sqlopts ;
1078         create table &outputds as
1079         select distinct i.MRN
1080             , i.&IndexDateVarName
1081             , coalesce(w.MI           , 0) as  MI            label = "Myocardial
1081     ! Infarction: "
1082             , coalesce(w.CHD          , 0) as  CHD           label = "Congestive heart
1082     ! disease: "
1083             , coalesce(w.PVD          , 0) as  PVD           label = "Peripheral vascular
1083     ! disorder: "
1084             , coalesce(w.CVD          , 0) as  CVD           label = "Cerebrovascular
1084     ! disease: "
1085             , coalesce(w.DEM          , 0) as  DEM           label = "Dementia: "
1086             , coalesce(w.CPD          , 0) as  CPD           label = "Chronic pulmonary
1086     ! disease: "
1087             , coalesce(w.RHD          , 0) as  RHD           label = "Rheumatologic
1087     ! disease: "
1088             , coalesce(w.PUD          , 0) as  PUD           label = "Peptic ulcer disease:
1088     !  "
1089             , coalesce(w.MLIVD        , 0) as  MLIVD         label = "Mild liver disease: "
1090             , coalesce(w.DIAB         , 0) as  DIAB          label = "Diabetes: "
1091             , coalesce(w.DIABC        , 0) as  DIABC         label = "Diabetes with chronic
1091     !  complications: "
1092             , coalesce(w.PLEGIA       , 0) as  PLEGIA        label = "Hemiplegia or
1092     ! paraplegia: "
1093             , coalesce(w.REN          , 0) as  REN           label = "Renal Disease: "
1094             , coalesce(w.MALIGN       , 0) as  MALIGN        label = "Malignancy, including
1094     !  leukemia and lymphoma: "
1095             , coalesce(w.SLIVD        , 0) as  SLIVD         label = "Moderate or severe
1095     ! liver disease: "
1096             , coalesce(w.MST          , 0) as  MST           label = "Metastatic solid
1096     ! tumor: "
24                                       The SAS System          06:31 Tuesday, November 8, 2005

1097             , coalesce(w.AIDS         , 0) as  AIDS          label = "AIDS: "
1098             , coalesce(w.&IndexVarName, 0) as  &IndexVarName label = "Charlson score: "
1099             , (w.MRN is null)              as  NoVisitFlag   label = "No visits for this
1099     ! person"
1100         from _ppl as i left join _WithCharlson as w
1101         on i.MRN = w.MRN
1102         ;
1103       
1104       /* clean up work sas datasets */
1105       proc datasets nolist ;
1106        delete _DxSubset
1107               _PxSubset
1108               _DxAssign
1109               _PxAssign
1110               _DxPxAssign
1111               _WithCharlson
1112               _NoVisit
1113               _ppl
1114               ;
1115       %mend charlson;
1116       
1117       %macro PullContinuous2(InSet                     /* The name of the input dataset of
1117     ! MRNs of the ppl whose enrollment you want to check. */
1118                            , OutSet                    /* The name of the output dataset of
1118     !  only the continuously enrolled people. */
1119                            , IndexDate                 /* Either the name of a date
1119     ! variable in InSet, or, a complete date literal (e.g., "01Jan2005"d) */
1120                            , PreIndexEnrolledMonths    /* The # of months of enrollment
1120     ! required prior to the index date. */
1121                            , PreIndexGapTolerance      /* The length of enrollment gaps you
1121     !  consider to be ignorable for pre-index date enrollment. */
1122                            , PostIndexEnrolledMonths   /* The # of months of enrollment
1122     ! required post index date. */
1123                            , PostIndexGapTolerance     /* The length of enrollment gaps you
1123     !  consider to be ignorable for post-index date enrollment.*/
1124                            , EnrollDset = __enroll.&_EnrollData /* For testing. */
1125                            ) ;
1126       
1127       
1128       
1129          %* Validate the arguments. ;
1130          %if &PreIndexGapTolerance > &PreIndexEnrolledMonths %then %do ;
1131             %put WARNING: Pre-index gap tolerance cannot be greater than the number of
1131     ! months of desired pre-index enrollment. ;
1132             %put Setting the pre-index gap tolerance to &PreIndexEnrolledMonths ;
1133             %let PreIndexGapTolerance = &PreIndexEnrolledMonths ;
1134          %end ;
1135       
1136          %if &PostIndexGapTolerance > &PostIndexEnrolledMonths %then %do ;
1137             %put WARNING: Post-index gap tolerance cannot be greater than the number of
1137     ! months of desired Post-index enrollment. ;
1138             %put Setting the Post-index gap tolerance to &PostIndexEnrolledMonths ;
1139             %let PostIndexGapTolerance = &PostIndexEnrolledMonths ;
25                                       The SAS System          06:31 Tuesday, November 8, 2005

1140          %end ;
1141       
1142       
1143          %put ;
1144          %put ;
1145          %put ============================================================== ;
1146          %put ;
1147          %put Macro PullContinuous2a: ;
1148          %put ;
1149          %put Creating a dataset "&OutSet", which will look exactly like  ;
1150          %put dataset "&InSet", except that anyone not enrolled for &PreIndexEnrolledMonths
1150     !  ;
1151          %put months prior to &IndexDate (disregarding gaps of up to &PreIndexGapTolerance
1151     ! month(s)) AND ;
1152          %put &PostIndexEnrolledMonths months after &IndexDate (disregarding gaps of up to
1152     ! &PostIndexGapTolerance month(s)) will;
1153          %put be eliminated.;
1154          %put ;
1155          %put ============================================================== ;
1156          %put ;
1157          %put ;
1158       
1159          libname __enroll "&_EnrollLib" access = readonly ;
1160       
1161          proc sql feedback ;
1162             * Create a dset to hold the output data. ;
1163             create table &OutSet
1164             like &InSet ;
1165       
1166       
1167             %* We only need our peoples enroll recs over the period from (IndexDate -
1167     ! (PreIndexEnrolledMonths + PreIndexGapTolerance))
1168             %* to                                                        (IndexDate +
1168     ! (PostIndexEnrolledMonths + PostIndexGapTolerance). ;
1169             %* These vars simplify the expressions a bit... ;
1170             %let PreMonthCount  = %eval(&PreIndexEnrolledMonths  + &PreIndexGapTolerance) ;
1171             %let PostMonthCount = %eval(&PostIndexEnrolledMonths + &PostIndexGapTolerance)
1171     ! ;
1172       
1173             * This statement is only conditioned on ENR_Year b/c I want to be able to use
1173     ! the index ;
1174             * on that var if possible. ;
1175             create table _grist as
1176             select e.MRN
1177                   , mdy(e.Enr_Month, 1, e.Enr_Year) as EnrollDate format = mmddyy10.
1178                   , &IndexDate                      as IDate      format = mmddyy10.
1179             from  &EnrollDset as e INNER JOIN
1180                   &InSet as i
1181             on    e.MRN = i.MRN
1182             WHERE ENR_Year BETWEEN year(intnx("MONTH", &IndexDate, -&PreMonthCount)) AND
1183                                    year(intnx("MONTH", &IndexDate, &PostMonthCount))
1184             ;
1185       
26                                       The SAS System          06:31 Tuesday, November 8, 2005

1186             * Since the above is only conditioned on ENR_Year, we need to now get rid of
1186     ! extraneous records ;
1187             * that fall outside the range ;
1188             delete from _grist
1189             where EnrollDate not BETWEEN intnx("MONTH", IDate, -&PreMonthCount) AND
1190                                          intnx("MONTH", IDate, &PostMonthCount)
1191             ;
1192       
1193             * Anybody enrolled for a total of &PreIndexEnrolledMonths +
1193     ! &PostIndexEnrolledMonths months
1194             * was definitely continuously enrolled, and definitely belongs in the output
1194     ! dset. ;
1195             create table _continuously_enrolled as
1196             select MRN
1197             from _grist
1198             group by MRN
1199             having count(*) ge (&PreMonthCount + &PostMonthCount + 1)
1200             ;
1201       
1202             %put ;
1203             %put ;
1204             %put &SQLOBS people were continuously enrolled during the pre/post index date
1204     ! period of interest. ;
1205             %put ;
1206             %put ;
1207       
1208       
1209             * Move their data into outset. ;
1210             insert into &OutSet
1211             select *
1212             from &InSet
1213             where MRN in (select MRN from _continuously_enrolled) ;
1214       
1215             * Remove these continuously-enrolled people from _grist, for efficiencys sake.
1215     ! ;
1216             delete from _grist
1217             where MRN in (select MRN from _continuously_enrolled) ;
1218       
1219             drop table _continuously_enrolled ;
1220       
1221          quit ;
1222       
1223          * Who has a gap longer than the tolerance? ;
1224          proc sort data = _grist ;
1225             by MRN EnrollDate ;
1226          run ;
1227       
1228          data debug _insufficiently_enrolled ;
1229             retain _LastDate . ;
1230             set _grist ;
1231             by MRN EnrollDate ;
1232       
1233             format _LastDate mmddyy10. ;
27                                       The SAS System          06:31 Tuesday, November 8, 2005

1234             * For *most* recs we want to eval the difference between this recs EnrollDate,
1234     ! and the one on the last rec. ;
1235             * We always expect a 1-month gap, so we subtract out the expected gap. ;
1236             ThisGap = intck("MONTH", _LastDate, EnrollDate) - 1 ;
1237             EndGap = 0 ;
1238       
1239       
1240             * Two rec types are special--firsts and lasts w/in an MRN group. ;
1241             if first.MRN then ThisGap = intck("MONTH", intnx("MONTH", IDate,
1241     ! -&PreIndexEnrolledMonths), EnrollDate) ;
1242             if last.MRN  then EndGap  = intck("MONTH", EnrollDate, intnx("MONTH", IDate,
1242     ! &PostIndexEnrolledMonths)) ;
1243       
1244             * Ignore the smaller of the two gaps. ;
1245             MaxGap = max(ThisGap, EndGap) ;
1246       
1247             if (ThisGap gt &PreIndexGapTolerance) or (EndGap gt &PostIndexGapTolerance)
1247     ! then do ;
1248                output _insufficiently_enrolled ;
1249                put mrn= ThisGap= EndGap=  ;
1250             end ;
1251             /*
1252             if MaxGap gt 0 then do ;
1253                * Weve got a gap--see if it is pre or post index date, and whether it
1253     ! exceeds the appropriate tolerance. ;
1254                if EnrollDate le IDate then do ;
1255                   * The gap ends before the index date--eval just the pre-gap ;
1256                   if ThisGap gt (&PreIndexGapTolerance) then output
1256     ! _insufficiently_enrolled ;
1257                end ;
1258                else do ;
1259                   * Its a post-index gap ;
1260                   * Does the gap cross the index date? ;
1261                   if _LastDate le IDate then do ;
1262                      * Straddle--eval both pre and post gaps ;
1263                      * ThisGap = <<diff between LastDate and IDate>> ;
1264                      ThisGap = intck("MONTH", _LastDate, IDate) - 1  ;
1265                      * EndGap = <<diff between IDate and EnrollDate>> ;
1266                      EndGap = intck("MONTH", IDate, EnrollDate) - 1 ;
1267                      if ThisGap gt (&PreIndexGapTolerance) or EndGap gt
1267     ! (&PostIndexGapTolerance) then output _insufficiently_enrolled ;
1268                   end ;
1269                   else do ;
1270                      * No straddle--evaluate just against the post-index gap tolerance. ;
1271                      if MaxGap gt (&PostIndexGapTolerance) then output
1271     ! _insufficiently_enrolled ;
1272                   end ;
1273                end ;
1274             end ;
1275             */
1276             output debug ;
1277             _LastDate = EnrollDate ;
1278          run ;
28                                       The SAS System          06:31 Tuesday, November 8, 2005

1279          data s.debug ;
1280             set debug ;
1281          run ;
1282          proc sql ;
1283             * Remove the insufficiently-enrolled people from _grist, so that dset has only
1283     ! the IDs of people who passed the gap testing. ;
1284             delete from _grist
1285             where MRN in (select MRN from _insufficiently_enrolled) ;
1286       
1287             insert into &OutSet
1288             select *
1289             from  &InSet
1290             where MRN in (select MRN from _grist) ;
1291       
1292             drop table _grist ;
1293             drop table _insufficiently_enrolled ;
1294          quit ;
1295       
1296          libname __enroll clear ;
1297       %mend PullContinuous2 ;
1298       
1299       %macro GetFollowUpTime(People    /* Dset of MRNs */
1300                      , IndexDate       /* Name of a date var in &People, or else a date
1300     ! literal, marking the start of the follow-up period. */
1301                      , EndDate         /* Name of a date var in &People, or else a complete
1301     !  date literal, marking the end of the period of interest. */
1302                      , GapTolerance    /* Number of months disenrollment to ignore in
1302     ! deciding the disenrollment date. */
1303                      , CallEndDateVar  /* What name should we give the date var that will
1303     ! hold the end of the f/up period? */
1304                      , OutSet          /* The name of the output dataset. */
1305                        ) ;
1306       
1307       
1308          %put ;
1309          %put ;
1310          %put ============================================================== ;
1311          %put ;
1312          %put Macro GetFollowUpTime V0.80: ;
1313          %put ;
1314          %put Creating a dset "&OutSet", which will look just like "&People" except that ;
1315          %put it will have an additional variable "&CallEndDateVar", which will hold the
1315     ! earliest of ;
1316          %put date-of-last-enrollment, or &EndDate (or, if the person was not enrolled at
1316     ! all ;
1317          %put a missing value). ;
1318          %put ;
1319          %put THIS IS BETA SOFTWARE--PLEASE SCRUTINIZE THE RESULTS AND REPORT ANY PROBLEMS!
1319     !  ;
1320          %put ;
1321          %put ============================================================== ;
1322          %put ;
1323          %put ;
29                                       The SAS System          06:31 Tuesday, November 8, 2005

1324       
1325       
1326          %* Use this to save interim dsets for later inspection. ;
1327          %*let debuglib = owt. ;
1328          %let debuglib = ;
1329       
1330          libname __enroll "&_EnrollLib" access = readonly ;
1331       
1332          proc sql ;
1333       
1334             %* Grab ENROLL recs for our ppl of interest, between &IndexDate and EndDate. ;
1335             %* This semi-redundant WHERE clause is b/c I want to be able to use an index on
1335     !  ;
1336             %* enr_year if there is one. ;
1337             %* The intnx() stuff is to make up for the month-level precision of the
1337     ! EnrollDate. ;
1338             create table &debuglib._grist as
1339             select distinct e.MRN
1340                   , &IndexDate                  as idate       format = mmddyy10.
1341                   , &EndDate                    as edate       format = mmddyy10.
1342                   , mdy(enr_month, 1, enr_year) as EnrollDate  format = mmddyy10.
1343             from __enroll.&_EnrollData as e INNER JOIN
1344                   &People as p
1345             on    e.MRN = p.MRN
1346             where e.enr_year between year(&IndexDate) and year(&EndDate) AND
1347                   CALCULATED EnrollDate between intnx('MONTH', &IndexDate, 0, 'BEGINNING')
1348                                             and intnx('MONTH', &EndDate  , 0, 'END') ;
1349          quit ;
1350       
1351          * Who has a gap longer than the tolerance? ;
1352          proc sort data = &debuglib._grist ;
1353             by MRN EnrollDate ;
1354          run ;
1355       
1356          data &debuglib._gap_ends ;
1357             retain _LastDate . ;
1358             set &debuglib._grist ;
1359             by MRN EnrollDate ;
1360       
1361             format _LastDate mmddyy10. ;
1362       
1363             * For *most* recs we want to eval the difference between this recs EnrollDate,
1363     ! and the one on the last rec. ;
1364             * We always expect a 1-month gap, so we subtract out the expected gap. ;
1365             ThisGap = intck("MONTH", _LastDate, EnrollDate) - 1 ;
1366             EndGap = 0 ;
1367       
1368             * But two rec types are special--firsts and lasts w/in an MRN group. ;
1369             select ;
1370                * For first MRN recs, the gap we need to eval is the one from the ;
1371                * start of the period of interest to the current EnrollDate--so redefine
1371     ! ThisGap. ;
1372                when (first.MRN) ThisGap = intck("MONTH", IDate, EnrollDate) ;
30                                       The SAS System          06:31 Tuesday, November 8, 2005

1373                * For last MRN recs, we have an additional gap to consider--the one between
1373     ! ;
1374                * EnrollDate and the end of the period of interest.  So redefine EndGap. ;
1375                when (last.MRN)  EndGap = intck("MONTH", EnrollDate, EDate) ;
1376                otherwise ; * Do nothing! ;
1377             end ;
1378       
1379             if max(ThisGap, EndGap) gt (&GapTolerance) then do ;
1380                * Weve got an intolerable gap somewhere. ;
1381                /*
1382                   There are 3 types of gaps:
1383                      - Leading (gaps between index and first EnrollDate).
1384                      - Interim (gaps entirely embraced by Index and End).
1385                      - Trailing (gaps between EnrollDate and End).
1386       
1387                   For a Leading gap, the f/up time should be 0.
1388                   For an Interim gap, the f/up time runs from Index to the last EnrollDate
1388     ! prior to the gap.
1389                   For a Trailing gap, the f/up time should run from Index to the last
1389     ! EnrollDate.
1390       
1391                   In the next step, we remove records from _grist w/enrolldates on or after
1392                   the one on the earliest gap.
1393       
1394                   So--since ppl w/Trailing gaps are actually enrolled on this EnrollDate
1395                   we will bump their enrolldate by one month, so they get credit for being
1396                   enrolled during this month.
1397       
1398                */
1399       
1400                select ;
1401                   when (first.MRN) do ;
1402                      * Its a leading gap--meaning no relevant enrollment hx. ;
1403                      EnrollDate = idate ;
1404                   end ;
1405                   when (last.MRN) do ;
1406                      * Could be either an interim or a trailing gap, or both. ;
1407                      * If *just* a trailing, we need to bump EnrollDate by a month. ;
1408                      if ThisGap le (&GapTolerance) then EnrollDate = intnx('MONTH',
1408     ! EnrollDate, 1) ;
1409                   end ;
1410                   otherwise ; * Do nothing! ;
1411                end ;
1412                output ;
1413             end ;
1414       
1415             _LastDate = EnrollDate ;
1416          run ;
1417       
1418       
1419          proc sql ;
1420             * Dset _gap_ends contains MRN/EDate combos for the *ends* of all impermissible
1420     ! gaps.  Find each persons first such gap. ;
31                                       The SAS System          06:31 Tuesday, November 8, 2005

1421             create table &debuglib._first_gaps as
1422             select MRN, min(EnrollDate) as EndFirstGap format = mmddyy10.
1423             from &debuglib._gap_ends
1424             group by MRN
1425             ;
1426       
1427             * Remove any recs from grist that are on or after each persons first
1427     ! impermissible gap. ;
1428             create table &debuglib._clean_grist as
1429             select g.MRN, g.EnrollDate
1430             from  &debuglib._grist as g LEFT JOIN
1431                   &debuglib._first_gaps as f
1432             on    g.MRN = f.MRN
1433             where f.MRN IS NULL OR
1434                   g.EnrollDate lt f.EndFirstGap
1435             ;
1436       
1437             %if %length(&debuglib) = 0 %then drop table &debuglib._grist ; ;
1438             %if %length(&debuglib) = 0 %then drop table &debuglib._gap_ends ; ;
1439       
1440            * Now find each persons last enrollment date. ;
1441            * Right now these are firsts-of-the-month.  Should we bump them to lasts? Yes. ;
1442             create table &debuglib._last_enroll_dates as
1443             select MRN, intnx('MONTH', max(EnrollDate), 0, 'END') as LastEnrollDate format
1443     ! = mmddyy10.
1444             from &debuglib._clean_grist
1445             group by MRN
1446             ;
1447       
1448             %if %length(&debuglib) = 0 %then drop table &debuglib._clean_grist ; ;
1449       
1450             %* Finally, write the new var to &People. ;
1451             create table &OutSet as
1452             select p.*
1453                  ,  case
1454                         when l.MRN IS NULL then .
1455                         else min(&EndDate, LastEnrollDate)
1456                     end as &CallEndDateVar format = mmddyy10.
1457             from &People as p LEFT JOIN
1458                   &debuglib._last_enroll_dates as l
1459             on    p.MRN = l.MRN
1460             ;
1461       
1462             %if %length(&debuglib) = 0 %then drop table &debuglib._first_gaps ; ;
1463          quit ;
1464       
1465          libname __enroll clear ;
1466       %mend GetFollowUpTime ;

NOTE: SAS Institute Inc., SAS Campus Drive, Cary, NC USA 27513-2414
NOTE: The SAS System used:
      real time           10.11 seconds
      cpu time            1.79 seconds
32                                       The SAS System          06:31 Tuesday, November 8, 2005

      
