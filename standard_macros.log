1                                                          The SAS System                               17:43 Friday, April 16, 2010

NOTE: Copyright (c) 2002-2008 by SAS Institute Inc., Cary, NC, USA. 
NOTE: SAS (r) Proprietary Software 9.2 (TS1M0) 
      Licensed to GROUP HEALTH COOPERATIVE OF PUGET SOUND, Site 70007081.
NOTE: This session is executing on the XP_PRO  platform.



NOTE: SAS initialization used:
      real time           31.86 seconds
      cpu time            0.93 seconds
      
ERROR: File is in use, \\ctrhs-sas\Warehouse\Sas\Includes\SASstart\startup.log.
WARNING: The data set WORK.PARDRE1 may be incomplete.  When this step was stopped there were 0 observations and 8 variables.
1          /*********************************************
2          * Roy Pardee
3          * Center For Health Studies
4          * (206) 287-2078
5          * pardee.r@ghc.org
6          *
7          * \\groups\data\CTRHS\Crn\S D R C\VDW\Macros\standard_macros.sas
8          *
9          * Contains standard VDW macros for use against VDW data.
10         *
11         * These macros are documented here:
12         * https://appliedresearch.cancer.gov/crnportal/data-resources/vdw/vdw-standard-macros
13         *
14         * Anything documented on that page is supported--please report bugs to pardee.r@ghc.org.
15         *
16         * You will find other macros in this file--most are helpers for the documented macros.  There may
17         * also be a vestigial macro or two (there are none when I write this comment, but who knows what
18         * the future may bring?).  Any such macros are unsupported.
19         *
20         *********************************************/
21         
22         * Utility macro for fairly precisely calculating age. ;
23         %macro CalcAge(BDtVar, RefDate) ;
24            %if %length(&BDtVar) = 0 %then %let BDtVar = birth_date ;
25            intck('YEAR', &BDtVar, &RefDate) -
26            (mdy(month(&RefDate), Day(&RefDate), 2004) <
27             mdy(month(&BDtVar) , day(&BDtVar) , 2004))
28         %mend CalcAge ;
29         
30         %macro GetRxForPeople(
31                  People   /* The name of a dataset containing the MRNs of people
32                              whose fills you want. */
33                , StartDt  /* The date on which you want to start collecting fills. */
34                , EndDt    /* The date on which you want to stop collecting fills. */
35                , Outset   /* The name of the output dataset containing the fills. */
36                ) ;
37         
38            /*
39               Gets the pharmacy fills for a specified set of people (identified by MRNs)
40               which ocurred between the dates specified in StartDt and EndDt.
2                                                          The SAS System                               17:43 Friday, April 16, 2010

41            */
42            libname __rx "&_RxLib." access = readonly ;
43         
44            %if &People = &Outset %then %do ;
45             %put PROBLEM: The People dataset must be different from the OutSet dataset.;
46             %put PROBLEM: Both parameters are set to "&People". ;
47             %put PROBLEM: Doing nothing. ;
48            %end ;
49            %else %do ;
50               proc sql ;
51                  create table &OutSet as
52                  select r.*
53                  from __rx.&_RxData as r INNER JOIN
54                        &People as p
55                  on    r.MRN = p.MRN
56                  where r.RxDate BETWEEN "&StartDt"d AND "&EndDt"d ;
57               quit ;
58            %end ;
59            libname __rx clear;
60         %mend GetRxForPeople ;
61         /*********************************************************;
62         * Testing GetRxForPeople (tested Ok 20041230 gh);
63         * ;
64         %include '\\Groups\data\CTRHS\Crn\S D R C\VDW\Macros\StdVars.sas';
65         
66         data PeopleIn;
67           infile '\\Groups\data\CTRHS\Crn\S D R C\VDW\Macros\testchs100.txt';
68           input mrn $char10.;
69         run;
70         
71         %GetRxForPeople(PeopleIn,01Jan2002,31Dec2002,RxOut) ;
72         **********************************************************/;
73         
74         
75         %macro GetRxForDrugs(
76                     DrugLst  /* The name of a dataset containing the NDCs of the drugs
77                                  whose fills you want. */
78                   , StartDt  /* The date on which you want to start collecting fills.*/
79                   , EndDt    /* The date on which you want to stop collecting fills. */
80                   , Outset   /* The name of the output dataset containing the fills. */
81                   ) ;
82         
83            /*
84               Gets the pharmacy fills for a specified set of drugs (identified by NDCs)
85               which ocurred between the dates specified in StartDt and EndDt.
86            */
87         
88            %if &DrugLst = &Outset %then %do ;
89              %put PROBLEM: Drug List dataset must be different from the OutSet dataset.;
90              %put PROBLEM: Both parameters are set to "&DrugLst". ;
91              %put PROBLEM: Doing nothing. ;
92            %end ;
93            %else %do ;
3                                                          The SAS System                               17:43 Friday, April 16, 2010

94               libname __rx "&_RxLib" access = readonly ;
95               proc sql ;
96                  create table &OutSet as
97                  select r.*
98                  from __rx.&_RxData as r INNER JOIN
99                        &DrugLst as p
100                 on    r.NDC = p.NDC
101                 where r.RxDate BETWEEN "&StartDt"d AND "&EndDt"d ;
102              quit ;
103              libname __rx clear ;
104           %end ;
105        %mend GetRxForDrugs ;
106        
107        %macro GetRxForPeopleAndDrugs(
108                   People   /* The name of a dataset containing the people
109                               whose fills you want. */
110                 , DrugLst  /* The NDC codes of interest */
111                 , StartDt  /* The date on which you want to start collecting fills.*/
112                 , EndDt    /* The date on which you want to stop collecting fills. */
113                 , Outset   /* The name of the output dataset containing the fills. */
114                 ) ;
115        
116           /*
117              Gets the pharmacy fills for a specified set of people (identified by MRNs)
118              which occurred between the dates specified in StartDt and EndDt.
119           */
120        
121           %if &People = &Outset %then %do ;
122            %put PROBLEM: The People dataset must be different from the OutSet dataset.;
123            %put PROBLEM: Both parameters are set to "&People". ;
124            %put PROBLEM: Doing nothing. ;
125           %end ;
126           %else %do ;
127              libname __rx "&_RxLib" access = readonly ;
128              proc sql ;
129          	    create table &OutSet as
130        	  			select r.*
131           				from  __rx.&_Rxdata as r
132           				INNER JOIN &People as p
133           				on    r.MRN = p.MRN
134           				where r.RxDate BETWEEN "&StartDt"d AND "&EndDt"d AND
135                 				r.NDC in (select _x.NDC from &DrugLst as _x) ;
136              quit ;
137              libname __rx clear ;
138           %end ;
139        %mend GetRxForPeopleAndDrugs ;
140        
141        %macro GetDxForPeopleAndDx (
142                   People  /* The name of a dataset containing the people whose
143                              fills you want. */
144                 , DxLst   /* The ICD9 codes of interest */
145                 , StartDt /* The date on which you want to start collecting fills.*/
146                 , EndDt   /* The date on which you want to stop collecting fills. */
4                                                          The SAS System                               17:43 Friday, April 16, 2010

147                 , Outset  /* The name of the output dataset containing the fills. */
148                 ) ;
149           libname __dx "&_UtilizationLib" access = readonly ;
150        
151           %if &People = &Outset %then %do ;
152            %put PROBLEM: The People dataset must be different from the OutSet dataset.;
153            %put PROBLEM: Both parameters are set to "&People". ;
154            %put PROBLEM: Doing nothing. ;
155           %end ;
156        
157           %else %do ;
158              proc sql ;
159                create table &outset as
160        			  select d.*
161           			from  __dx.&_dxdata as d
162           			INNER JOIN &People as p
163           			on    d.MRN = p.MRN
164           			where d.ADate BETWEEN "&StartDt"d AND "&EndDt"d AND
165           						d.dx in (select _x.dx from &DxLst as _x)
166                ;
167              quit ;
168           %end ;
169           libname __dx clear ;
170        
171        %mend GetDxForPeopleAndDx;
172        
173        %macro CountFills(DrugList) ;
174           /*
175              Counts the number of fills for each of the NDC codes specified in
176              the input dataset.
177           */
178        
179           libname __rx "&_RxLib" access = readonly ;
180        
181           proc sql ;
182              title2 "Extent of pharmacy data." ;
183              select count(*) as NumFills label = "Total rx records"
184                    , min(RxDate) as FirstFill
185                        format = mmddyy10. label = "Earliest recorded fill"
186                    , max(RxDate) as LastFill
187                        format = mmddyy10. label = "Most recent recorded fill"
188              from __rx.&_RxData ;
189        
190              title2 "Number of fills for the list of NDCs in &DrugList" ;
191              select d.generic
192                    , d.NDC
193                    , count(r.NDC) as NumFills label = "Number of Fills"
194                    , min(r.RxDate) as FirstFill
195                        format = mmddyy10. label = "Date of first fill"
196                    , max(r.RxDate) as LastFill
197                        format = mmddyy10. label = "Date of most recent fill"
198              from  &DrugList as d LEFT JOIN
199                    __rx.&_RxData as r
5                                                          The SAS System                               17:43 Friday, April 16, 2010

200              on    d.NDC = r.NDC
201              group by d.generic, d.NDC ;
202           quit ;
203        
204           libname __rx clear ;
205        %mend CountFills ;
206        
207        %macro BreastCancerDefinition01(StartDt = 01Jan1997
208                                      , EndDt = 31Dec2003
209                                      , OutSet = brca) ;
210           /*
211              Pulls the set of "incident" (that is, first-ocurring during the
212              specified date range) breast cancers, both invasive and in-situ
213              (but excluding LCIS).
214        
215              These criteria are based on the ones used for the Early Screening study.
216              See: https://www.kpchr.org/CRN2/apps/storage/docs/
217                                    20000823whmesprogramming_case_criteria.doc.
218           */
219        
220           libname __tum "&_TumorLib" access = readonly ;
221        
222           proc sql number ;
223              create table _AllBreastTumors as
224              select mrn
225                    , DxDate
226                    , DtMrk1 as ERMarker
227                    , StageGen
228                    , StageAJ
229              from  __tum.&_TumorData
230              where DxDate between "&StartDt"d and "&EndDt"d  AND
231                    ICDOSite between 'C500' and 'C509'        AND
232                    Gender = '2'                              AND
233                    Morph NOT between '9590' and '9979'       AND
234                    ( (behav in ('3', '6', '9')) OR
235                      (behav = '2' AND MORPH ne '8520')) ;
236        
237              create table _FirstBTs as
238              select DISTINCT b.*
239              from  _AllBreastTumors as b
240                INNER JOIN
241                    (select MRN, min(DxDate) as FirstBTDate
242                      from _AllBreastTumors group by MRN) as b2
243              on    b.MRN = b2.MRN AND
244                    b.DxDate = b2.FirstBTDate
245              order by mrn, ERMarker ;
246        
247              drop table _AllBreastTumors ;
248        
249              title "These people had >1 tumor dxd on the same day, ";
250              title2 "each with different receptor statuses or stages." ;
251              select *
252              from  _FirstBTs
6                                                          The SAS System                               17:43 Friday, April 16, 2010

253              where MRN in (select _FirstBTs.MRN from _FirstBTs group by _FirstBTs.MRN having count(*) > 1);
254              title ;
255        
256              * Some women will have > 1 breast tumor dxd on the same day, each with ;
257              * different stages and/or receptor statuses.  We want to call the ;
258              * receptor status positive if any tumor is positive, and we want to ;
259              * take the greatest stage. ;
260        
261              create table &OutSet as
262              select mrn
263                    , dxdate
264                    , min(case ERMarker
265                             when '0' then 10
266                             else input(ERMarker, 2.0)
267                          end) as ERMarker format = ERM.
268                    , max(case lowcase(StageGen)
269                             when '9' then -1
270                             when 'b' then -2
271                             else input(StageGen, 2.0)
272                          end) as StageGen format = StageGen.
273                    , max(case lowcase(StageAJ)
274                             when '' then -1
275                             when 'unk' then -1
276                             when '2a' then 2
277                             when '2b' then 2.5
278                             when '3a' then 3
279                             when '3b' then 3.5
280                             else input(StageAJ, 2.0)
281                          end) as StageAJ format = StageAJ.
282              from _FirstBTs
283              group by mrn, dxdate ;
284           quit ;
285        
286           libname __tum clear ;
287        
288        %mend BreastCancerDefinition01 ;
289        
290        %macro BreastCancerDefinition02(StartDt = 01Jan1997
291                                      , EndDt = 31Dec2003
292                                      , OutSet = brca
293                                      , OutMultFirsts =
294                                      ) ;
295           /*
296            Adapted from 01, for Pharmacovigilance.  Differences:
297              01 includes DCIS (but not LCIS).  This is invasive tumors only.
298              Returns a dataset of *tumors*, not *women*.  There are frequently > 1 tumor discovered as a
299              "first tumor" so applications will have to reduce that to women if necessary.
300              Not so much printing (but optional output dset).
301              More warnings.
302        
303              TODO: Try and nail down a more HMO-site-general list of morphology codes
304                    to exclude.  These have just had scrutiny from the Group Health
305                    staff and on the Group Health data.
7                                                          The SAS System                               17:43 Friday, April 16, 2010

306           */
307        
308          %local female ;
309          %let   female = 2 ;
310        
311          %local collab_stage_year ;
312          %let collab_stage_year = 2003 ;
313        
314          %local behav_primary ;
315          %local behav_metastatic ;
316          %local behav_unknown_prim_meta ;
317        
318          %let behav_primary = 3 ;
319          %let behav_metastatic = 6 ;
320          %let behav_unknown_prim_meta = 9 ;
321        
322          %* These appeared in some GH breast tumor data--they are undesirable. ;
323          %local non_small_cell ;
324          %local neuroendicrine ;
325          %local fibrosarcoma ;
326        
327          %let non_small_cell = 8046 ;
328          %let neuroendicrine = 8246 ;
329          %let fibrosarcoma = 8810 ;
330        
331          %local in_situ ;
332          %let in_situ = 0 ;
333        
334          proc sql number ;
335            * We take these over all time since the file is small and we want to be ;
336            * able to call the resulting cases "incident" insofar as we can ;
337            create table _AllBreastTumors as
338            select *
339            from  &_vdw_tumor
340            where DxDate le "&EndDt"d                  AND
341                  Gender = "&female"                   AND
342                  ICDOSite between 'C500' and 'C509'   AND
343                  Morph NOT between '9590' and '9979'  AND
344                  Morph NOT in ("&non_small_cell", "&neuroendicrine", "&fibrosarcoma" ) AND
345                  behav in ("&behav_primary", "&behav_unknown_prim_meta") AND
346                  stagegen ^= "&in_situ"
347            ;
348        
349            * Check desired date limits against observed, and warn as necessary. ;
350            select  min(dxdate) as first_tumor   format = yymmddn8. label = "First observed breast tumor (over all time)"
351                  , max(dxdate) as last_tumor    format = yymmddn8. label = "Last observed breast tumor (over all time)"
352                  , "&StartDt"d as desired_first format = yymmddn8.
353                  , "&EndDt"d   as desired_last  format = yymmddn8.
354            into :first_tumor, :last_tumor, :desired_first, :desired_last
355            from _AllBreastTumors
356            ;
357        
358            %if &desired_first < &first_tumor %then %do i = 1 %to 10 ;
8                                                          The SAS System                               17:43 Friday, April 16, 2010

359              %put WARNING: NO BREAST TUMORS FOUND PRIOR TO &STARTDT (EARLIEST IS &FIRST_TUMOR)--EARLY TUMORS MAY NOT BE AS
359      ! "INCIDENT" AS LATER ONES!!! ;
360            %end ;
361        
362            %if &desired_last > &last_tumor %then %do i = 1 %to 10 ;
363              %put WARNING: NO BREAST TUMORS FOUND AFTER &LAST_TUMOR.--THE &_TUMORDATA FILE IS NOT EXTENSIVE ENOUGH TO MEET THIS
363      ! REQUEST!!! ;
364            %end ;
365        
366            * Grab all tumors from each womans first dxdate. ;
367            create table _FirstBTs as
368            select DISTINCT b.*
369            from  _AllBreastTumors as b
370              INNER JOIN
371                  (select MRN, min(DxDate) as FirstBTDate
372                   from _AllBreastTumors
373                   group by MRN
374                   having min(DxDate) between "&StartDt"d and "&EndDt"d) as b2
375            on    b.MRN = b2.MRN AND
376                  b.DxDate = b2.FirstBTDate
377            order by mrn, dxdate;
378        
379            drop table _AllBreastTumors ;
380        
381            * Who had > 1 breast tumor discovered on the day of their first tumor? ;
382            create table _multiple_firsts as
383            select *
384            from  _FirstBTs
385            where MRN in (select _FirstBTs.MRN
386                          from _FirstBTs
387                          group by _FirstBTs.MRN
388                          having count(*) > 1)
389            ;
390        
391            %if &SQLOBS > 0 %then %do ;
392              %do i = 1 %to 5 ;
393                %PUT BCD2 NOTE: There is at least one, and may be as many as %eval(&SQLOBS/2) people with > 1 tumor dignosed on
393      ! the same day, each with different receptor statuses or stages. ;
394              %end ;
395              %if %length(&OutMultFirsts) > 0 %then %do ;
396                create table &OutMultFirsts as
397                select *
398                from _multiple_firsts
399                ;
400                %do i = 1 %to 5 ;
401                  %put BCD2 NOTE: The multiple-first-tumor records have been written out to &OutMultFirsts ;
402                %end ;
403              %end ;
404        
405            %end ;
406        
407            create table &OutSet as
408            select *
9                                                          The SAS System                               17:43 Friday, April 16, 2010

409            from _FirstBTs
410            ;
411          quit ;
412        
413        %mend BreastCancerDefinition02 ;
414        
415        %macro PullContinuous(InSet                     /* The name of the input dataset of MRNs of the ppl whose enrollment you
415      ! want to check. */
416                             , OutSet                    /* The name of the output dataset of only the continuously enrolled
416      ! people. */
417                             , IndexDate                 /* Either the name of a date variable in InSet, or, a complete date
417      ! literal (e.g., "01Jan2005"d) */
418                             , PreIndexEnrolledMonths    /* The # of months of enrollment required prior to the index date. */
419                             , PreIndexGapTolerance      /* The length of enrollment gaps you consider to be ignorable for
419      ! pre-index date enrollment. */
420                             , PostIndexEnrolledMonths   /* The # of months of enrollment required post index date. */
421                             , PostIndexGapTolerance     /* The length of enrollment gaps you consider to be ignorable for
421      ! post-index date enrollment.*/
422                             , DebugOut = work           /* Libname to save interim dsets to for debugging--leave set to work to
422      ! discard these. */
423                             , EnrollDset = __enroll.&_EnrollData /* For testing. */
424                             ) ;
425        
426           %* Validate the arguments. ;
427           %if &PreIndexGapTolerance > &PreIndexEnrolledMonths %then %do ;
428              %put WARNING: Pre-index gap tolerance cannot be greater than the number;
429              %put WARNING: of months of desired pre-index enrollment.;
430        
431              %let PreIndexGapTolerance = %eval(&PreIndexEnrolledMonths - 1) ;
432              %put Setting the pre-index gap tolerance to &PreIndexGapTolerance ;
433           %end ;
434        
435           %if &PostIndexGapTolerance > &PostIndexEnrolledMonths %then %do ;
436              %put WARNING: Post-index gap tolerance cannot be greater than the number;
437              %put WARNING: of months of desired Post-index enrollment.;
438        
439              %let PostIndexGapTolerance = %eval(&PostIndexEnrolledMonths - 1) ;
440              %put Setting the Post-index gap tolerance to &PostIndexGapTolerance ;
441           %end ;
442        
443        
444           %put ;
445           %put ;
446           %put ============================================================== ;
447           %put ;
448           %put Macro PullContinuous: ;
449           %put ;
450           %put Creating a dataset "&OutSet", which will look exactly like            ;
451           %put dataset "&InSet", except that anyone not enrolled for                 ;
452           %put &PreIndexEnrolledMonths months prior to &IndexDate (disregarding gaps ;
453           %put of up to &PreIndexGapTolerance month(s)) AND &PostIndexEnrolledMonths ;
454           %put months after &IndexDate (disregarding gaps of up to                   ;
455           %put &PostIndexGapTolerance month(s)) will be eliminated.                  ;
10                                                         The SAS System                               17:43 Friday, April 16, 2010

456           %put ;
457           %put ============================================================== ;
458           %put ;
459           %put ;
460        
461           libname __enroll "&_EnrollLib" access = readonly ;
462        
463           proc sql ;
464              * Table of unique MRNs and the dates setting out the period of interest (earliest & latest). ;
465              create table __ids as
466              select distinct mrn
467                 , &IndexDate                                                         as idate    format = mmddyy10.
468                 , intnx('MONTH', &IndexDate, -&PreIndexEnrolledMonths, 'BEGINNING')  as earliest format = mmddyy10.
469                 , intnx('MONTH', &IndexDate,  &PostIndexEnrolledMonths, 'END')       as latest   format = mmddyy10.
470              from &InSet
471              ;
472        
473              * Make sure we only have one record per MRN. ;
474              create table __drop_me as
475              select mrn, count(* ) as appears_num_times
476              from __ids
477              group by mrn
478              having count(*) > 1 ;
479        
480              %if &sqlobs > 0 %then %do ;
481                 %PUT ;
482                 %PUT ;
483                 %PUT ;
484                 %PUT ;
485                 %PUT ;
486                 %PUT ERROR: &SQLOBS MRNs appear more than once in the input datset with different index dates! ;
487                 %PUT ERROR: &SQLOBS MRNs appear more than once in the input datset with different index dates! ;
488                 %PUT ERROR: &SQLOBS MRNs appear more than once in the input datset with different index dates! ;
489                 %PUT ;
490                 %PUT See the .lst file for a list of duplicated MRNs ;
491                 %PUT ;
492                 %PUT ;
493                 %PUT ;
494                 %PUT ;
495                 %PUT ;
496                 reset outobs = 20 nowarn ;
497                 select * from __drop_me ;
498                 %*abort return ;
499                 %goto exit;
500              %end ;
501        
502              reset outobs = max ;
503        
504              drop table __drop_me ;
505        
506              * Grab out the enroll records that could possibly contribute to the period of interest. ;
507              create table __enroll as
508              select i.mrn, i.earliest, i.latest, i.idate, e.enr_start, e.enr_end
11                                                         The SAS System                               17:43 Friday, April 16, 2010

509              from  __ids as i INNER JOIN
510                    &EnrollDset as e
511              on    i.MRN = e.MRN
512              where i.earliest le e.enr_end AND
513                    i.latest   ge e.enr_start
514              order by mrn, enr_start
515              ;
516        
517              * Anybody w/no recs in __enroll could not possibly have been sufficiently enrolled. ;
518              create table __not_enrolled as
519              select i.mrn
520              from __ids as i LEFT JOIN
521                    __enroll as e
522              on    i.mrn = e.mrn
523              where e.mrn IS NULL ;
524           quit ;
525        
526           * Now we loop through the enroll records looking for gaps. ;
527           * There are 3 places where gaps can occur--before the start of enrollment, ;
528           * in the middle of enrollment (inter-record), and past the end of enrollment. ;
529           * First records for a person can only have before-enrollment gaps.  Middle records ;
530           * can only have an inter-record gap.  But Last records can have either or ;
531           * both an inter and a post-enrollment gap. ;
532           data &debugout..__insufficiently_enrolled ;
533              retain _last_end . ;
534              length reason $ 4 pre_gap_length post_gap_length 4 ;
535              set __enroll ;
536              by mrn ;
537              num_possible_gaps = 1 ;
538              if first.mrn then do ;
539                 * Earliest period for this person--there may be a gap between earliest & enr_start. ;
540                 possible_gap_start1 = earliest ;
541                 possible_gap_end1   = enr_start ;
542              end ;
543              else do ;
544                 * Middle or last rec--maybe an inter-record gap. ;
545                 possible_gap_start1 = _last_end ;
546                 possible_gap_end1   = enr_start ;
547              end ;
548              if last.mrn then do ;
549                 * Last period--may be a gap between end and latest. ;
550                 possible_gap_start2 = enr_end ;
551                 possible_gap_end2 = latest ;
552                 num_possible_gaps = 2 ;
553              end ;
554        
555              array starts{2} possible_gap_start: ;
556              array ends{2}   possible_gap_end: ;
557              * Loop through the 2 possible gaps, outputting anybody w/an out of tolerance gap. ;
558              do i = 1 to num_possible_gaps ;
559                 * We knock 1 off the number of months b/c we expect at least one month gap between contiguous periods. ;
560                 * No we dont. ;
561                 this_gap = intck('MONTH', starts{i}, ends{i}) ;
12                                                         The SAS System                               17:43 Friday, April 16, 2010

562        
563                 if this_gap > 0 then do ;
564                    /*
565                       We have an actual gap.  There are 3 possibilities.
566                          - The whole gap falls before the index date (possible_gap_end lt idate).
567                          - The whole gap falls after the index date (possible_gap_start gt idate).
568                          - The gap straddles the index date.
569                    */
570                    if ends{i} lt idate then do ;
571                       pre_gap_length = this_gap ;
572                       post_gap_length = 0 ;
573                    end ;
574                    else if starts{i} gt idate then do ;
575                       pre_gap_length = 0 ;
576                       post_gap_length = this_gap ;
577                    end ;
578                    else do ;   * Straddle gap--idate falls between gap start & gap end. ;
579                       pre_gap_length  = intck('MONTH', starts{i}, idate) ;
580                       post_gap_length = intck('MONTH', idate, ends{i})   ;
581                    end ;
582        
583                 end ;
584        
585                 if (pre_gap_length > &PreIndexGapTolerance) then do ;
586                    reason = 'pre' ;
587                    output ;
588                 end ;
589                 else if (post_gap_length > &PostIndexGapTolerance) then do ;
590                    reason = 'post' ;
591                    output ;
592                 end ;
593        
594              end ;
595              _last_end = enr_end + 1 ;
596              format _last_end possible_gap_start: possible_gap_end: mmddyy10. ;
597           run ;
598        
599           proc sql ;
600              create table &OutSet as
601              select * from &InSet
602              where mrn not in (select mrn from &debugout..__insufficiently_enrolled
603                                UNION ALL
604                                select mrn from __not_enrolled) ;
605              drop table __enroll ;
606              drop table __not_enrolled ;
607           quit ;
608        %exit:
609        %mend PullContinuous ;
610        
611        
612        %macro ndclookup(
613                 inds     /* An input dataset of strings to search for,
614                               in a var named "drugname".  */
13                                                         The SAS System                               17:43 Friday, April 16, 2010

615               , outds    /* The name of the output dset of NDCs,
616                               which contain one of the input strings. */
617               , EverNDC  /* The name of your local copy of the EverNDC file. */
618               );
619        
620        *******************************************************************************;
621        * look up NDC codes by drugnames or fragments of drugnames
622        * Check the results file to see that they are all drugs of interest
623        *
624        * Input:
625        *	inds is the name of the input SAS dataset with the list of character strings
626        *		to match contains the variable "drugname"
627        *		Both the Generic and Brand fields are searched for all input strings
628        *
629        *	outds is the name of the output SAS dataset
630        *       EverNDC is the SAS dataset name of the file of all NDCcodes
631        *
632        * EverNDC is the fully qualified name of your local copy of the EverNDC dataset
633        *
634        *    Example:
635        *Data StringsOfInterest;
636        *   input  drugname $char20.;
637        *   datalines;
638        *TAMOX
639        *Ralox
640        *NOLVADEX
641        *LETROZOLE
642        *EXEMESTANE
643        *ANASTROZOLE
644        
645        *%ndclookup(StringsOfInterest, NDCs_of_Interest, mylib.EverNDC);
646        *******************************************************************************;
647        
648          proc sql noprint ;
649        
650            * Create a monster WHERE clause to apply to ever_ndc from the contents   ;
651            * of InDs. The embedded single quotes can get a bit confusing--just      ;
652            * remember that one single quote character escapes the following one.  So;
653            * a string of 4 single-quote chars in a row defines a string containing  ;
654            * one single quote--the two on the ends delimit the string, and the two  ;
655            * in the middle resolve to one (the first one escaping the second).      ;
656            * SQL written by Roy Pardee                                              ;
657        
658            select 'upcase(n.Generic) LIKE ''%' || trim(upcase(s.DrugName))|| '%''' ||
659               ' OR upcase(n.Brand)   LIKE ''%' || trim(upcase(s.DrugName))|| '%'''
660                  as where_clause
661            into :wh separated by ' OR '
662            from &inds as s ;
663        
664            * First pull all of the NDCs that meet the WHERE clause above. ;
665            create table _OfInterest as
666            select distinct *
667            from &everndc as n
14                                                         The SAS System                               17:43 Friday, April 16, 2010

668            where &wh ;
669        
670            * Now pull drugs that *dont* match the WHERE clause, but share an NDC ;
671            *   with one that does. ;
672            create table _Suspicious as
673            select distinct n.*
674            from _OfInterest as a inner join &everndc as n
675            on a.ndc = n.ndc
676            where not (&wh)
677            ;
678        
679            * Mash the two dsets together ;
680            create table &outds as
681            select *, 0 as Suspicious
682              label = "Flag for whether Generic or Brand contained a string of interest"
683            from _OfInterest
684            UNION ALL
685            select *, 1 as Suspicious
686            from _Suspicious ;
687        
688            drop table _OfInterest ;
689            drop table _Suspicious ;
690          quit ;
691        %mend ndclookup;
692        
693        %macro GetPxForPeople(
694                   People  /* The name of a dataset containing the people whose
695                                 procedures you want. */
696                 , StartDt /* The date on which you want to start collecting procs*/
697                 , EndDt   /* The date on which you want to stop collecting procedures*/
698                 , Outset  /* The name of the output dataset containing the procedures*/
699                 ) ;
700        
701           /*
702              Gets the procedures for a specified set of people (identified by MRNs)
703              which ocurred between the dates specified in StartDt and EndDt.
704           */
705           libname __util "&_UtilizationLib" access = readonly ;
706        
707           %if &People = &Outset %then %do ;
708            %put PROBLEM: The People dataset must be different from the OutSet dataset.;
709            %put PROBLEM: Both parameters are set to "&People". ;
710            %put PROBLEM: Doing nothing. ;
711           %end ;
712           %else %do ;
713              proc sql ;
714                 create table &OutSet as
715                 select r.*
716                 from __util.&_PxData as r INNER JOIN
717                       &People as p
718                 on    r.MRN = p.MRN
719                 where r.ADate BETWEEN "&StartDt"d AND "&EndDt"d ;
720              quit ;
15                                                         The SAS System                               17:43 Friday, April 16, 2010

721           %end ;
722           libname __util clear ;
723        %mend GetPxForPeople ;
724        
725        %macro GetUtilizationForPeople(
726                  People  /* The name of a dataset containing the people whose
727                               procedures you want*/
728                , StartDt /* The date on which you want to start collecting procedures*/
729                , EndDt   /* The date on which you want to stop collecting procedures*/
730                , Outset  /* The name of the output dataset containing the procedures*/
731                ) ;
732        
733           /*
734              Gets the utilization records for a specified set of people (identified
735              by MRNs) hich ocurred between the dates specified in StartDt and EndDt.
736           */
737           libname __util "&_UtilizationLib" access = readonly ;
738        
739           %if &People = &Outset %then %do ;
740            %put PROBLEM: The People dataset must be different from the OutSet dataset.;
741            %put PROBLEM: Both parameters are set to "&People". ;
742            %put PROBLEM: Doing nothing. ;
743           %end ;
744           %else %do ;
745              proc sql ;
746                 create table &OutSet as
747                 select r.*
748                 from __util.&_UtilizationData as r INNER JOIN
749                       &People as p
750                 on    r.MRN = p.MRN
751                 where r.ADate BETWEEN "&StartDt"d AND "&EndDt"d ;
752              quit ;
753           %end ;
754           libname __util clear ;
755        %mend GetUtilizationForPeople ;
756        
757        /*********************************************************;
758        * Testing GetPxForPeople (tested ok 20041230 gh);
759        * ;
760        %include '\\Groups\data\CTRHS\Crn\S D R C\VDW\Macros\StdVars.sas';
761        
762        data PeopleIn;
763          infile '\\Groups\data\CTRHS\Crn\S D R C\VDW\Macros\testchs100.txt';
764          input mrn $char10.;
765        run;
766        
767        %GetPxForPeople(PeopleIn,01Jan2002,31Dec2002,PxOut) ;
768        **********************************************************/;
769        
770        %macro GetDxForPeople(
771                  People  /* The name of a dataset containing the people whose
772                               diagnoses you want. */
773                , StartDt /* The date on which you want to start collecting diagnoses.*/
16                                                         The SAS System                               17:43 Friday, April 16, 2010

774                , EndDt   /* The date on which you want to stop collecting diagnoses. */
775                , Outset  /* The name of the output dataset containing the diagnoses. */
776                ) ;
777        
778           /*
779              Gets the diagnoses for a specified set of people (identified by MRNs)
780              which ocurred between the dates specified in StartDt and EndDt.
781           */
782           libname __util "&_UtilizationLib" access = readonly ;
783           %if &People = &Outset %then %do ;
784            %put PROBLEM: The People dataset must be different from the OutSet dataset.;
785            %put PROBLEM: Both parameters are set to "&People". ;
786            %put PROBLEM: Doing nothing. ;
787           %end ;
788           %else %do ;
789              proc sql ;
790                 create table &OutSet as
791                 select r.*
792                 from __util.&_DxData as r INNER JOIN
793                       &People as p
794                 on    r.MRN = p.MRN
795                 where r.ADate BETWEEN "&StartDt"d AND "&EndDt"d ;
796              quit ;
797           %end ;
798           libname __util clear;
799        %mend GetDxForPeople ;
800        /*********************************************************;
801        * Testing GetDxForPeople (tested ok 20041230 gh);
802        * ;
803        %include '\\Groups\data\CTRHS\Crn\S D R C\VDW\Macros\StdVars.sas';
804        
805        data PeopleIn;
806          infile '\\Groups\data\CTRHS\Crn\S D R C\VDW\Macros\testchs100.txt';
807          input mrn $char10.;
808        run;
809        
810        %GetDxForPeople(PeopleIn,01Jan2002,31Dec2002,DxOut) ;
811        **********************************************************/;
812        
813        
814        %macro GetDxForDx(
815                  DxLst     /* The name of a dataset containing the diagnosis
816                                 list you want. */
817                , DxVarName /* The name of the DX variable in DxLst  */
818                , StartDt   /* The date on which you want to start collecting fills. */
819                , EndDt     /* The date on which you want to stop collecting fills. */
820                , Outset    /* The name of the output dataset containing the fills. */
821                ) ;
822        
823           /*
824             Gets the records for a specified set of diagnoses (identified by ICD9 code)
825             which ocurred between the dates specified in StartDt and EndDt.
826           */
17                                                         The SAS System                               17:43 Friday, April 16, 2010

827           libname __util "&_UtilizationLib" access = readonly ;
828           %if &DxLst = &Outset %then %do ;
829            %put PROBLEM: The Diagnosis List dataset must be different from the;
830            %put PROBLEM:   OutSet dataset;
831            %put PROBLEM: Both parameters are set to "&DxLst". ;
832            %put PROBLEM: Doing nothing. ;
833           %end ;
834           %else %do ;
835              proc sql ;
836                 create table &OutSet as
837                 select DBig.*
838                 from  __util.&_DxData as DBig INNER JOIN
839                       &DxLst as DLittle
840                 on    DBIG.DX = Dlittle.&DxVarName.
841                 where Dbig.ADate BETWEEN "&StartDt"d AND "&EndDt"d ;
842              quit ;
843           %end ;
844           libname __util clear;
845        %mend GetDxForDx ;
846        /*********************************************************;
847        * Testing GetDxForDx (tested 20041230 gh);
848        * ;
849        %include '\\Groups\data\CTRHS\Crn\S D R C\VDW\Macros\StdVars.sas';
850        
851        data DxOfInterest;
852          input dx $char6.;
853          cards;
854        V22   Normal pregnancy
855        V22.0       Supervision of normal first pregnancy
856        V22.1       Supervision of other normal pregnancy
857        V22.2       Pregnant state, incidental
858        run;
859        
860        %GetDxForDx(DxOfInterest, dx,01Jan2002,31Dec2002,DxOut) ;
861        **********************************************************/;
862        
863        %macro GetPxForPx(
864                  PxLst             /*The name of a dataset containing the procedure
865                                        list you want. */
866                , PxVarName         /*The name of the Px variable in PxLst  */
867                , PxCodeTypeVarName /*Px codetype variable name in PxLst  */
868                , StartDt           /*The date when you want to start collecting data*/
869                , EndDt             /*The date when you want to stop collecting data*/
870                , Outset            /*Name of the output dataset containing the data*/
871                ) ;
872        
873           /*
874             Gets the records for a specified set of diagnoses (identified by ICD9 code)
875             which ocurred between the dates specified in StartDt and EndDt.
876           */
877           libname __util "&_UtilizationLib" access = readonly ;
878           %if &PxLst = &Outset %then %do ;
879            %put PROBLEM: The Px List dataset must be different from the OutSet dataset;
18                                                         The SAS System                               17:43 Friday, April 16, 2010

880            %put PROBLEM: Both parameters are set to "&PxLst". ;
881            %put PROBLEM: Doing nothing. ;
882           %end ;
883           %else %do ;
884              proc sql ;
885                 create table &OutSet as
886                 select PBig.*
887                 from  __util.&_PxData as PBig INNER JOIN
888                       &PxLst as PLittle
889                 on    PBig.PX = PLittle.&PxVarName.  and
890                       /* will this screw up use of an index? gh */
891                       PBig.CodeType = PLittle.&PxCodeTypeVarName.
892                 where Pbig.ADate BETWEEN "&StartDt"d AND "&EndDt"d ;
893              quit ;
894           %end ;
895           libname __util clear ;
896        %mend GetPxForPx ;
897        *********************************************************;
898        * Testing GetPxForPx (tested 20041230 gh);
899        * ;
900        /*
901        %include '\\Groups\data\CTRHS\Crn\S D R C\VDW\Macros\StdVars.sas';
902        
903        data PxOfInterest;
904          input Px $char6. CodeType $char1.;
905          cards;
906        59409 C VAGINAL DELIVERY ONLY
907        59410 C  VAGINAL DELIVERY INCL POSTPARTUM CARE
908        59510 C  ROUTINE OB CARE INCL ANTEPARTUM CAR, CESAREAN DELIVER, POSTPARTUM CARE
909        59514 C  CESAREAN DELIVERY ONLY
910        run;
911        
912        %GetPxForPx(PxOfInterest, px, CodeType, 01Jan2002,31Dec2002,PxOut) ;
913        **********************************************************;
914        */
915        
916        /* *********************************************************
917        * Takes an input dataset bearing a specified ID code (e.g.,
918        * MRN) and replaces it with an arbitrary
919        * StudyID, creating a crosswalk dset that relates the
920        * original ID codes to the new StudyIDs.
921        *
922        * Sample call:
923        *
924        * %DeIDDset( InSet = phe.people    The input dataset.
925        *          , XWalkSet = phe.xwalk  Name of the crosswalk dset
926        *          , OldIDVar = CHSID      Name of the ID variable you want removed.
927        *          , NewIDVar = StudyID    Name for the new ID variable.
928        *          , NewIDLen = 8          The length of the new ID variable.
929        *          ) ;
930        ********************************************************* */
931        
932        %macro DeIDDset( InSet     /* Name of the dataset you want de-identified. */
19                                                         The SAS System                               17:43 Friday, April 16, 2010

933                       , XWalkSet  /* Name of the output ID-crosswalk dset. */
934                       , OldIDVar  /* Name of the ID variable you want removed. */
935                       , NewIDVar  /* Name for the new ID variable the macro creates. */
936                       , NewIDLen  /* The length of the new ID variable.*/
937                       , StartIDsAt = 0
938                       ) ;
939        
940           proc sql ;
941              create table _UIDs as
942              select distinct &OldIDVar
943              from &InSet ;
944           quit ;
945        
946           %if %length(%trim(&sqlobs)) > &NewIDLen %then %do ;
947              %put ;
948              %put PROBLEM: THE ID LENGTH SPECIFIED IS INSUFFICIENT!!! ;
949              %put ;
950              %put DOING NOTHING!!! ;
951              %put ;
952           %end ;
953           %else %do ;
954        
955              data &XWalkSet(keep = &NewIDVar &OldIDVar) ;
956                 set _UIDs ;
957                 &NewIDVar = put((_N_ + &StartIDsAt), z&NewIDLen..0) ;
958              run ;
959        
960              proc sql ;
961                 create table &InSet._DeIDed(drop = &OldIDVar) as
962                 select x.&NewIDVar
963                       , i.*
964                 from  &XWalkSet as x INNER JOIN
965                       &InSet as i
966                 on    x.&OldIDVar = i.&OldIDVar ;
967              quit ;
968        
969              data &InSet ;
970                 set &InSet._DeIDed ;
971              run ;
972        
973              proc sql ;
974                 drop table &InSet._DeIDed ;
975              quit ;
976        
977           %end ;
978        
979        %mend DeIDDset ;
980        
981        %macro charlson(inputds
982                      , IndexDateVarName
983                      , outputds
984                      , IndexVarName
985                      , inpatonly=I
20                                                         The SAS System                               17:43 Friday, April 16, 2010

986                      , malig=N
987                      );
988        /*********************************************
989        
990        * Charlson comorbidity macro.sas
991        *
992        * Computes the Deyo version of the Charleson
993        *
994        *
995        *  Programmer
996        *     Hassan Fouayzi
997        *
998        *
999        * Input data required:
1000       *
1001       *     VDW Utilization files
1002       *     Input SAS dataset INPUTDS
1003       *        contains the variables MRN, STUDYID, and INDEXDT
1004       *        INPATONLY flag - defauts to Inpatient only (I).  Valid values are
1005       *                           I-inpatient or B-Both inpatient and outpatient
1006       *                           or A-All encounter types
1007       *        MALIG flag - Defaults to no(N).  If MALIG is yes (Y) then the weights
1008       *                         of Metastasis and Malignancy are set to zero.
1009       *                     This may be useful in a study of cancer.
1010       * Outputs:
1011       *     Dataset &outputsd with on record per studyid
1012       *     Variables
1013       *       MI            = "Myocardial Infarction: "
1014       *       CHD           = "Congestive heart disease: "
1015       *       PVD           = "Peripheral vascular disorder: "
1016       *       CVD           = "Cerebrovascular disease: "
1017       *       DEM           = "Dementia: "
1018       *       CPD           = "Chronic pulmonary disease: "
1019       *       RHD           = "Rheumatologic disease: "
1020       *       PUD           = "Peptic ulcer disease: "
1021       *       MLIVD         = "Mild liver disease: "
1022       *       DIAB          = "Diabetes: "
1023       *       DIABC         = "Diabetes with chronic complications: "
1024       *       PLEGIA        = "Hemiplegia or paraplegia: "
1025       *       REN           = "Renal Disease: "
1026       *       MALIGN        = "Malignancy, including leukemia and lymphoma: "
1027       *       SLIVD         = "Moderate or severe liver disease: "
1028       *       MST           = "Metastatic solid tumor: "
1029       *       AIDS          = "AIDS: "
1030       *       &IndexVarName = "Charlson score: "
1031       *
1032       *
1033       * Dependencies:
1034       *
1035       *     StdVars.sas--the site-customized list of standard macro variables.
1036       *     The DX and PROC files to which stdvars.sas refer
1037       *
1038       *
21                                                         The SAS System                               17:43 Friday, April 16, 2010

1039       * Example of use:
1040       *     %charlson(testing,oot, Charles, inpatonly=B)
1041       *
1042       * Notes:
1043       *   You will often need to remove certain disease format categories for your
1044       *   project. For instance, the Ovarian Ca EOL study removed Metastatic Solid
1045       *   Tumor since all were in end stages. It would be inappopriate not to exclude
1046       *   this category in this instance. Please use this macro wisely.
1047       *
1048       *   There are several places that need to be modified.
1049       *     1.  Comment the diagnosis category in the format.
1050       *     2.  Remove that diagnosis category in 2 arrays.
1051       *     3.  Select the time period for the source data and a reference point.
1052       *     4.  Data selection.  All diagnoses and procedures?  Inpt only?  The user
1053       *         may want to remove certain types of data to make the sources from all
1054       *         sites consistent.
1055       *
1056       * Version History
1057       *
1058       *     Written by Hassan Fouayzi starting with source from Rick Krajenta
1059       *     Modified into a SAS Macro format           Gene Hart         2005/04/20
1060       *     Malig flag implemented                     Gene Hart         2005/05/04
1061       *     Add flag to mark thos with no visits       Gene Hart         2005/05/09
1062       *     Add additional codes to disease            Tyler Ross        2006/03/31
1063       *     Changed EncType for IP visits to new ut
1064       *       specs and allowed all visit types option Tyler Ross       2006/09/15
1065       *     Removed "456" from Moderate/Severe Liver   Hassan Fouayzi    2006/12/21
1066       *
1067       *     Should the coalesce function be on studyid or mrn?  1 MRN with 2 STUDYIDs
1068       *       could happen
1069       *
1070       *     move then proc codes to a format
1071       *
1072       * Source publication
1073       *     From: Fouayzi, Hassan [mailto:hfouayzi@meyersprimary.org]
1074       *     Sent: Wednesday, May 04, 2005 9:07 AM
1075       *     Subject: RE: VDW Charlson macro
1076       ...
1077       *     Deyo RA, Cherkin DC, Ciol MA. Adapting a clinical comorbidity Index for
1078       *     use with ICD-9-CM administrative databases.
1079       *       J Clin Epidemiol 1992; 45: 613-619.
1080       *     We added CPT codes and a couple of procedures for Peripheral
1081       *       vascular disorder.
1082       *
1083       *********************************************/
1084       
1085       /**********************************************/
1086       /*Define and format diagnosis codes*/
1087       /**********************************************/
1088       PROC FORMAT;
1089          VALUE $ICD9CF
1090       /* Myocardial infraction */
1091       	"410   "-"410.92",
22                                                         The SAS System                               17:43 Friday, April 16, 2010

1092       	"412   " = "MI"
1093       /* Congestive heart disease */
1094       	"428   "-"428.9 " = "CHD"
1095       /* Peripheral vascular disorder */
1096       	"440.20"-"440.24",
1097       	"440.31"-"440.32",
1098       	"440.8 ",
1099       	"440.9 ",
1100       	"443.9 ",
1101       	"441   "-"441.9 ",
1102       	"785.4 ",
1103       	"V43.4 ",
1104       	"v43.4 " = "PVD"
1105       /* Cerebrovascular disease */
1106           "430   "-"438.9 " = "CVD"
1107       /* Dementia */
1108       	"290   "-"290.9 " = "DEM"
1109       /* Chronic pulmonary disease */
1110       	"490   "-"496   ",
1111       	"500   "-"505   ",
1112       	"506.4 " =  "CPD"
1113       /* Rheumatologic disease */
1114       	"710.0 ",
1115         "710.1 ",
1116        	"710.4 ",
1117         "714.0 "-"714.2 ",
1118         "714.81",
1119         "725   " = "RHD"
1120       /* Peptic ulcer disease */
1121       	"531   "-"534.91" = "PUD"
1122       /* Mild liver disease */
1123       	"571.2 ",
1124       	"571.5 ",
1125       	"571.6 ",
1126       	"571.4 "-"571.49" = "MLIVD"
1127       /* Diabetes */
1128       	"250   "-"250.33",
1129       	"250.7 "-"250.73" = "DIAB"
1130       /* Diabetes with chronic complications */
1131       	"250.4 "-"250.63" = "DIABC"
1132       /* Hemiplegia or paraplegia */
1133       	"344.1 ",
1134       	"342   "-"342.92" = "PLEGIA"
1135       /* Renal Disease */
1136       	"582   "-"582.9 ",
1137       	"583   "-"583.7 ",
1138       	"585   "-"586   ",
1139       	"588   "-"588.9 " = "REN"
1140       /*Malignancy, including leukemia and lymphoma */
1141       	"140   "-"172.9 ",
1142       	"174   "-"195.8 ",
1143       	"200   "-"208.91" = "MALIGN"
1144       /* Moderate or severe liver disease */
23                                                         The SAS System                               17:43 Friday, April 16, 2010

1145       	"572.2 "-"572.8 ",
1146       	"456.0 "-"456.21" = "SLIVD"
1147       /* Metastatic solid tumor */
1148       	"196   "-"199.1 " = "MST"
1149       /* AIDS */
1150       	"042   "-"044.9 " = "AIDS"
1151       /* Other */
1152          other   = "other"
1153       ;
1154       run;
1155       
1156       * For debugging. ;
1157       %let sqlopts = feedback sortmsg stimer ;
1158       %*let sqlopts = ;
1159       
1160       ******************************************************************************;
1161       * subset to the utilization data of interest (add the people with no visits  *;
1162       *    back at the end                                                         *;
1163       ******************************************************************************;
1164       libname util "&_UtilizationLib." access = readonly ;
1165       
1166       **********************************************;
1167       * implement the Inpatient and Outpatient Flags;
1168       ********************************************** ;
1169       %if &inpatonly =I %then %let inpatout= AND EncType in ('IP');
1170       %else %if &inpatonly =B %then %let inpatout= AND EncType in ('IP','AV');
1171       %else %if &inpatonly =A %then %let inpatout=;
1172       %else %do;
1173         %Put ERROR in Inpatonly flag.;
1174         %Put Valid values are I for Inpatient and B for both Inpatient and Outpatient;
1175       %end;
1176       
1177       proc sql &sqlopts ;
1178       
1179          create table _ppl as
1180          select MRN, Min(&IndexDateVarName) as &IndexDateVarName format = mmddyy10.
1181          from &inputds
1182          group by MRN ;
1183       
1184          %let TotPeople = &SQLOBS ;
1185       
1186         alter table _ppl add primary key (MRN) ;
1187       
1188         create table  _DxSubset as
1189         select sample.mrn, &IndexDateVarName, adate, put(dx, $icd9cf.) as CodedDx
1190         from util.&_DxData as d INNER JOIN _ppl as sample
1191         ON    d.mrn = sample.mrn
1192         where adate between sample.&IndexDateVarName-1
1193                         and sample.&IndexDateVarName-365
1194                   &inpatout.
1195         ;
1196       
1197          select count(distinct MRN) as DxPeople format = comma.
24                                                         The SAS System                               17:43 Friday, April 16, 2010

1198            label = "No. people having any Dxs w/in a year prior to &IndexDateVarName"
1199                , (CALCULATED DxPeople / &TotPeople) as PercentWithDx
1200                   format = percent6.2 label = "Percent of total"
1201          from _DxSubset ;
1202       
1203         create table _PxSubset as
1204         select p.*
1205         from util.&_PxData as p, _ppl as sample
1206         where p.mrn = sample.mrn
1207               and adate between sample.&IndexDateVarName-1
1208                             and sample.&IndexDateVarName-365
1209               &inpatout.
1210         ;
1211       
1212          select count(distinct MRN) as PxPeople format = comma.
1213            label = "No. people who had any Pxs w/in a year prior to &IndexDateVarName"
1214                , (CALCULATED PxPeople / &TotPeople) as PercentWithPx
1215                    format = percent6.2 label = "Percent of total sample"
1216          from _PxSubset ;
1217       
1218       quit ;
1219       
1220       proc sort data = _DxSubset ;
1221          by MRN ;
1222       run ;
1223       
1224       proc sort data = _PxSubset ;
1225          by MRN ;
1226       run ;
1227       
1228       /**********************************************/
1229       /*** Assing DX based flagsts                ***/
1230       /***                                        ***/
1231       /***                                        ***/
1232       /**********************************************/
1233       
1234       %let var_list = MI CHD PVD CVD DEM CPD RHD PUD MLIVD DIAB
1235                       DIABC PLEGIA REN MALIGN SLIVD MST AIDS ;
1236       
1237       data _DxAssign ;
1238       array COMORB (*) &var_list ;
1239       
1240       length &var_list 3 ; *<-This is host-specific--are we sure we want to do this?;
1241       
1242       retain           &var_list ;
1243       keep   mrn  &var_list ;
1244       set _DxSubset;
1245       by mrn;
1246       if first.mrn then do;
1247          do I=1 to dim(COMORB);
1248             COMORB(I) = 0 ;
1249          end;
1250       end;
25                                                         The SAS System                               17:43 Friday, April 16, 2010

1251       select (CodedDx);
1252          when ('MI')    MI     = 1;
1253          when ('CHD')   CHD    = 1;
1254          when ('PVD')   PVD    = 1;
1255          when ('CVD')   CVD    = 1;
1256          when ('DEM')   DEM    = 1;
1257          when ('CPD')   CPD    = 1;
1258          when ('RHD')   RHD    = 1;
1259          when ('PUD')   PUD    = 1;
1260          when ('MLIVD') MLIVD  = 1;
1261          when ('DIAB')  DIAB   = 1;
1262          when ('DIABC') DIABC  = 1;
1263          when ('PLEGIA')PLEGIA = 1;
1264          when ('REN')   REN    = 1;
1265          when ('MALIGN')MALIGN = 1;
1266          when ('SLIVD') SLIVD  = 1;
1267          when ('MST')   MST    = 1;
1268          when ('AIDS')  AIDS   = 1;
1269          otherwise ;
1270       end;
1271       if last.mrn then output;
1272       run;
1273       
1274       /** Procedures: Peripheral vascular disorder **/
1275       data _PxAssign;
1276          set _PxSubset;
1277          by mrn;
1278          retain PVD ; * [RP] Added 5-jul-2007, at Hassan Fouyazis suggestion. ;
1279          keep mrn PVD;
1280          if first.mrn then PVD = 0;
1281          if    PX= "38.48" or
1282                PX ="93668" or
1283                PX in ("34201","34203","35454","35456","35459","35470") or
1284                       "35355" <= PX <= "35381" or
1285                PX in ("35473","35474","35482","35483","35485","35492","35493",
1286                       "35495","75962","75992") or
1287                PX in ("35521","35533","35541","35546","35548","35549","35551",
1288                       "35556","35558","35563","35565","35566","35571","35582",
1289                       "35583","35584","35585","35586","35587","35621","35623",
1290                       "35641","35646","35647","35651","35654","35656","35661",
1291                       "35663","35665","35666","35671")
1292                then PVD=1;
1293          if last.mrn then output;
1294       run;
1295       
1296       /** Connect DXs and PROCs together  **/
1297       proc sql &sqlopts ;
1298         create table _DxPxAssign as
1299          select  coalesce(D.MRN, P.MRN) as MRN
1300                , D.MI
1301                , D.CHD
1302                , max(D.PVD, P.PVD) as PVD
1303                , D.CVD
26                                                         The SAS System                               17:43 Friday, April 16, 2010

1304                , D.DEM
1305                , D.CPD
1306                , D.RHD
1307                , D.PUD
1308                , D.MLIVD
1309                , D.DIAB
1310                , D.DIABC
1311                , D.PLEGIA
1312                , D.REN
1313                , D.MALIGN
1314                , D.SLIVD
1315                , D.MST
1316                , D.AIDS
1317          from  WORK._DXASSIGN as D full outer join
1318                WORK._PXASSIGN P
1319          on    D.MRN = P.MRN
1320          ;
1321       quit ;
1322       
1323       *****************************************************;
1324       * Assign the weights and compute the index
1325       *****************************************************;
1326       
1327       Data _WithCharlson;
1328         set _DxPxAssign;
1329         M1=1;M2=1;M3=1;
1330       
1331       * implement the MALIG flag;
1332          %if &malig =N %then %do; O1=1;O2=1; %end;
1333          %else %if &malig =Y %then  %do; O1=0; O2=0; %end;
1334          %else %do;
1335            %Put ERROR in MALIG flag.  Valid values are Y (Cancer study. Zero weight;
1336            %Put ERROR the cancer vars)  and N (treat cancer normally);
1337          %end;
1338       
1339         if SLIVD=1 then M1=0;
1340         if DIABC=1 then M2=0;
1341         if MST=1 then M3=0;
1342       
1343       &IndexVarName =   MI + CHD + PVD + CVD + DEM + CPD + RHD +
1344                         PUD + M1*MLIVD + M2*DIAB + 2*DIABC + 2*PLEGIA + 2*REN +
1345                         O1*2*M3*MALIGN + 3*SLIVD + O2*6*MST + 6*AIDS;
1346       
1347       Label
1348         MI            = "Myocardial Infarction: "
1349         CHD           = "Congestive heart disease: "
1350         PVD           = "Peripheral vascular disorder: "
1351         CVD           = "Cerebrovascular disease: "
1352         DEM           = "Dementia: "
1353         CPD           = "Chronic pulmonary disease: "
1354         RHD           = "Rheumatologic disease: "
1355         PUD           = "Peptic ulcer disease: "
1356         MLIVD         = "Mild liver disease: "
27                                                         The SAS System                               17:43 Friday, April 16, 2010

1357         DIAB          = "Diabetes: "
1358         DIABC         = "Diabetes with chronic complications: "
1359         PLEGIA        = "Hemiplegia or paraplegia: "
1360         REN           = "Renal Disease: "
1361         MALIGN        = "Malignancy, including leukemia and lymphoma: "
1362         SLIVD         = "Moderate or severe liver disease: "
1363         MST           = "Metastatic solid tumor: "
1364         AIDS          = "AIDS: "
1365         &IndexVarName = "Charlson score: "
1366       ;
1367       
1368       keep MRN &var_list &IndexVarName ;
1369       
1370       run;
1371       
1372       /* add the people with no visits back in, and create the final dataset */
1373       /* people with no visits or no comorbidity DXs have all vars set to zero */
1374       
1375       proc sql &sqlopts ;
1376         create table &outputds as
1377         select distinct i.MRN
1378             , i.&IndexDateVarName
1379             , coalesce(w.MI           , 0) as  MI
1380                          label = "Myocardial Infarction: "
1381             , coalesce(w.CHD          , 0) as  CHD
1382                          label = "Congestive heart disease: "
1383             , coalesce(w.PVD          , 0) as  PVD
1384                          label = "Peripheral vascular disorder: "
1385             , coalesce(w.CVD          , 0) as  CVD
1386                          label = "Cerebrovascular disease: "
1387             , coalesce(w.DEM          , 0) as  DEM
1388                          label = "Dementia: "
1389             , coalesce(w.CPD          , 0) as  CPD
1390                          label = "Chronic pulmonary disease: "
1391             , coalesce(w.RHD          , 0) as  RHD
1392                          label = "Rheumatologic disease: "
1393             , coalesce(w.PUD          , 0) as  PUD
1394                          label = "Peptic ulcer disease: "
1395             , coalesce(w.MLIVD        , 0) as  MLIVD
1396                          label = "Mild liver disease: "
1397             , coalesce(w.DIAB         , 0) as  DIAB
1398                          label = "Diabetes: "
1399             , coalesce(w.DIABC        , 0) as  DIABC
1400                          label = "Diabetes with chronic complications: "
1401             , coalesce(w.PLEGIA       , 0) as  PLEGIA
1402                          label = "Hemiplegia or paraplegia: "
1403             , coalesce(w.REN          , 0) as  REN
1404                          label = "Renal Disease: "
1405             , coalesce(w.MALIGN       , 0) as  MALIGN
1406                          label = "Malignancy, including leukemia and lymphoma: "
1407             , coalesce(w.SLIVD        , 0) as  SLIVD
1408                          label = "Moderate or severe liver disease: "
1409             , coalesce(w.MST          , 0) as  MST
28                                                         The SAS System                               17:43 Friday, April 16, 2010

1410                          label = "Metastatic solid tumor: "
1411             , coalesce(w.AIDS         , 0) as  AIDS
1412                          label = "AIDS: "
1413             , coalesce(w.&IndexVarName, 0) as  &IndexVarName
1414                          label = "Charlson score: "
1415             , (w.MRN is null)              as  NoVisitFlag
1416                          label = "No visits for this person"
1417         from _ppl as i left join _WithCharlson as w
1418         on i.MRN = w.MRN
1419         ;
1420       
1421       /* clean up work sas datasets */
1422       proc datasets nolist ;
1423        delete _DxSubset
1424               _PxSubset
1425               _DxAssign
1426               _PxAssign
1427               _DxPxAssign
1428               _WithCharlson
1429               _NoVisit
1430               _ppl
1431               ;
1432       %mend charlson;
1433       
1434       %macro OldGetFollowUpTime(People    /* Dset of MRNs */
1435                      , IndexDate       /* Name of a date var in &People, or else a
1436                                           date literal, marking the start of the
1437                                           follow-up period. */
1438                      , EndDate         /* Name of a date var in &People, or else a
1439                                           complete date literal, marking the end of
1440                                           the period of interest. */
1441                      , GapTolerance    /* Number of months disenrollment to ignore in
1442                                           deciding the disenrollment date. */
1443                      , CallEndDateVar  /* What name should we give the date var that
1444                                           will hold the end of the f/up period? */
1445                      , OutSet          /* The name of the output dataset. */
1446                        ) ;
1447       
1448       
1449          %put ;
1450          %put ;
1451          %put ============================================================== ;
1452          %put ;
1453          %put Macro GetFollowUpTime V0.80: ;
1454          %put ;
1455          %put Creating a dset "&OutSet", which will look just like "&People" except ;
1456          %put that it will have an additional variable "&CallEndDateVar", which will ;
1457          %put hold the earliest of date-of-last-enrollment, or &EndDate (or, if the ;
1458          %put person was not enrolled at all a missing value). ;
1459          %put ;
1460          %put THIS IS BETA SOFTWARE-PLEASE SCRUTINIZE THE RESULTS AND REPORT PROBLEMS;
1461          %put ;
1462          %put ============================================================== ;
29                                                         The SAS System                               17:43 Friday, April 16, 2010

1463          %put ;
1464          %put ;
1465       
1466       
1467          %* Use this to save interim dsets for later inspection. ;
1468          %*let debuglib = owt. ;
1469          %let debuglib = ;
1470       
1471          libname __enroll "&_EnrollLib" access = readonly ;
1472       
1473          proc sql ;
1474       
1475           %* Grab ENROLL recs for our ppl of interest, between &IndexDate and EndDate;
1476           %* This semi-redundant WHERE clause is b/c I want to use an index on;
1477           %* enr_year if there is one.;
1478           %* The intnx() makes up for the month-level precision of the EnrollDate;
1479             create table &debuglib._grist as
1480             select distinct e.MRN
1481                   , &IndexDate                  as idate       format = mmddyy10.
1482                   , &EndDate                    as edate       format = mmddyy10.
1483                   , mdy(enr_month, 1, enr_year) as EnrollDate  format = mmddyy10.
1484             from __enroll.&_EnrollData as e INNER JOIN
1485                   &People as p
1486             on    e.MRN = p.MRN
1487             where e.enr_year between year(&IndexDate) and year(&EndDate) AND
1488                  CALCULATED EnrollDate between intnx('MONTH',&IndexDate,0,'BEGINNING')
1489                                            and intnx('MONTH',&EndDate  ,0,'END') ;
1490          quit ;
1491       
1492          * Who has a gap longer than the tolerance? ;
1493          proc sort data = &debuglib._grist ;
1494             by MRN EnrollDate ;
1495          run ;
1496       
1497          data &debuglib._gap_ends ;
1498             retain _LastDate . ;
1499             set &debuglib._grist ;
1500             by MRN EnrollDate ;
1501       
1502             format _LastDate mmddyy10. ;
1503       
1504             * For *most* recs we want to eval the difference between this recs;
1505             *   EnrollDate, and the one on the last rec. ;
1506             * We always expect a 1-month gap, so we subtract out the expected gap. ;
1507             ThisGap = intck("MONTH", _LastDate, EnrollDate) - 1 ;
1508             EndGap = 0 ;
1509       
1510             * But two rec types are special--firsts and lasts w/in an MRN group. ;
1511             select ;
1512                * For first MRN recs, the gap we need to eval is the one from the ;
1513                * start of the period of interest to the current EnrollDate
1514                *   --so redefine ThisGap. ;
1515                when (first.MRN) ThisGap = intck("MONTH", IDate, EnrollDate) ;
30                                                         The SAS System                               17:43 Friday, April 16, 2010

1516                * For last MRN recs, we have an additional gap to consider;
1517                *  --the one between ;
1518                * EnrollDate and the end of the period of interest. So redefine EndGap;
1519                when (last.MRN)  EndGap = intck("MONTH", EnrollDate, EDate) ;
1520                otherwise ; * Do nothing! ;
1521             end ;
1522       
1523             if max(ThisGap, EndGap) gt (&GapTolerance) then do ;
1524                * Weve got an intolerable gap somewhere. ;
1525                /*
1526                   There are 3 types of gaps:
1527                      - Leading (gaps between index and first EnrollDate).
1528                      - Interim (gaps entirely embraced by Index and End).
1529                      - Trailing (gaps between EnrollDate and End).
1530       
1531                   For a Leading gap, the f/up time should be 0.
1532                   For an Interim gap, the f/up time runs from Index to the last
1533                      EnrollDate prior to the gap.
1534                   For a Trailing gap, the f/up time should run from Index to
1535                      the last EnrollDate.
1536       
1537                   In the next step, we remove records from _grist w/enrolldates on or
1538                   after the one on the earliest gap.
1539       
1540                   So-since ppl w/Trailing gaps are enrolled on this EnrollDate we will
1541                   bump their enrolldate by one month, so they get credit for being
1542                   enrolled during this month.
1543       
1544                */
1545       
1546                select ;
1547                   when (first.MRN) do ;
1548                      * Its a leading gap--meaning no relevant enrollment hx. ;
1549                      EnrollDate = idate ;
1550                   end ;
1551                   when (last.MRN) do ;
1552                      * Could be either an interim or a trailing gap, or both. ;
1553                      * If *just* a trailing, we need to bump EnrollDate by a month. ;
1554                      if ThisGap le (&GapTolerance)
1555                        then EnrollDate = intnx('MONTH', EnrollDate, 1) ;
1556                   end ;
1557                   otherwise ; * Do nothing! ;
1558                end ;
1559                output ;
1560             end ;
1561       
1562             _LastDate = EnrollDate ;
1563          run ;
1564       
1565       
1566          proc sql ;
1567             * Dset _gap_ends contains MRN/EDate combos for the *ends* of all ;
1568             *   impermissible gaps.  Find each persons first such gap. ;
31                                                         The SAS System                               17:43 Friday, April 16, 2010

1569             create table &debuglib._first_gaps as
1570             select MRN, min(EnrollDate) as EndFirstGap format = mmddyy10.
1571             from &debuglib._gap_ends
1572             group by MRN
1573             ;
1574       
1575             * Remove any recs from grist that are on or after each persons ;
1576             *   first impermissible gap. ;
1577             create table &debuglib._clean_grist as
1578             select g.MRN, g.EnrollDate
1579             from  &debuglib._grist as g LEFT JOIN
1580                   &debuglib._first_gaps as f
1581             on    g.MRN = f.MRN
1582             where f.MRN IS NULL OR
1583                   g.EnrollDate lt f.EndFirstGap
1584             ;
1585       
1586             %if %length(&debuglib) = 0 %then drop table &debuglib._grist ; ;
1587             %if %length(&debuglib) = 0 %then drop table &debuglib._gap_ends ; ;
1588       
1589            * Now find each persons last enrollment date. ;
1590            * Right now these are firsts-of-the-month.  ;
1591            *   Should we bump them to lasts? Yes. ;
1592             create table &debuglib._last_enroll_dates as
1593             select MRN
1594                  , intnx('MONTH', max(EnrollDate), 0, 'END')
1595                      as LastEnrollDate format = mmddyy10.
1596             from &debuglib._clean_grist
1597             group by MRN
1598             ;
1599       
1600             %if %length(&debuglib) = 0 %then drop table &debuglib._clean_grist ; ;
1601       
1602             %* Finally, write the new var to &People. ;
1603             create table &OutSet as
1604             select p.*
1605                  ,  case
1606                         when l.MRN IS NULL then .
1607                         else min(&EndDate, LastEnrollDate)
1608                     end as &CallEndDateVar format = mmddyy10.
1609             from &People as p LEFT JOIN
1610                   &debuglib._last_enroll_dates as l
1611             on    p.MRN = l.MRN
1612             ;
1613       
1614             %if %length(&debuglib) = 0 %then drop table &debuglib._first_gaps ; ;
1615          quit ;
1616       
1617          libname __enroll clear ;
1618       %mend OldGetFollowUpTime ;
1619       
1620       %macro LastWord(WordList) ;
1621          %* This is a helper macro for CollapsePeriods--it just returns the last word (variable name) in a string (var list). ;
32                                                         The SAS System                               17:43 Friday, April 16, 2010

1622          %let i = 0 ;
1623          %do %until(&ThisWord = ) ;
1624             %let i = %eval(&i + 1) ;
1625             %let ThisWord = %scan(&WordList, &i) ;
1626          %end ;
1627          %let i = %eval(&i - 1) ;
1628          %* Note the lack of a semicolon on the next line--thats on purpose! ;
1629          %scan(&WordList, &i)
1630       %mend LastWord ;
1631       
1632       %macro GetVarList(DSet         /* Name of the dset you want collapsed. */
1633                       , RecStart     /* Name of the var that contains the period start dates. */
1634                       , RecEnd       /* Name of the var that contains the period end dates. */
1635                      , PersonID  = MRN   /* Name of the var that contains a unique person identifier. */
1636                       ) ;
1637       
1638          %* This is also a helper macro for CollapsePeriods--it creates a global macro var ;
1639          %* containing a list of all vars in the input named dset *other than* the ones that ;
1640          %* define the start/end of each record. ;
1641       
1642          %* I dont know a good way of passing a return value out of a macro--so this is made global. ;
1643          %global VarList ;
1644       
1645          /*
1646       
1647          Dictionary.Columns is a dynamically-created dataset, consisting of one row per
1648          variable per dataset, in all of the currently defined libraries.
1649       
1650          My understanding is that sas will only create this 'table' if you issue
1651          a query against it.
1652       
1653          There can be ersatz errors caused by the creation of this table when there
1654          are sql views contained in a defined libname whose source tables
1655          are not resolvable.
1656       
1657          Dictionary.columns looks like this:
1658       
1659          create table DICTIONARY.COLUMNS
1660         (
1661          libname  char(8)     label='Library Name',
1662          memname  char(32)    label='Member Name',
1663          memtype  char(8)     label='Member Type',
1664          name     char(32)    label='Column Name',
1665          type     char(4)     label='Column Type',
1666          length   num         label='Column Length',
1667          npos     num         label='Column Position',
1668          varnum   num         label='Column Number in Table',
1669          label    char(256)   label='Column Label',
1670          format   char(16)    label='Column Format',
1671          informat char(16)    label='Column Informat',
1672          idxusage char(9)     label='Column Index Type'
1673         );
1674       
33                                                         The SAS System                               17:43 Friday, April 16, 2010

1675          */
1676       
1677          %* If we got just a one-part dset name for a WORK dataset, add the WORK libname explicitly. ;
1678       
1679          %if %index(&Dset, .) = 0 %then %do ;
1680             %let Dset = work.&Dset ;
1681          %end ;
1682       
1683          %*put Dset is &Dset ; ;
1684       
1685          proc sql noprint ;
1686             * describe table dictionary.columns ;
1687             select name
1688             into :VarList separated by ' '
1689             from dictionary.columns
1690             where memtype ne 'VIEW' AND
1691                   upcase(compress(libname || '.' || memname)) = %upcase("&Dset") AND
1692                   upcase(name) not in (%upcase("&RecStart"), %upcase("&RecEnd")) ;
1693          quit ;
1694       
1695       %mend GetVarList ;
1696       
1697       
1698       ** DEPRECATED--DO NOT USE. ;
1699       %macro OLDCollapsePeriods(Lib          /* Name of the library containing the dset you want collapsed */
1700                            , DSet         /* Name of the dset you want collapsed. */
1701                            , RecStart     /* Name of the var that contains the period start dates. */
1702                            , RecEnd       /* Name of the var that contains the period end dates. */
1703                            , DaysTol = 1  /* The number of days gap to tolerate in evaluating whether one period is contiguous
1703     ! w/another. */
1704                            , Debug   = 0  /* 0/1 flag indicating whether you want the PUT statements to run (PRODUCES A LOT OF
1704     ! OUTPUT!). */
1705                            ) ;
1706       
1707          %* Takes an input mbhist dataset and collapses contiguous time periods where the variables ;
1708          %* other than the ones defining period start/stop dates dont change. ;
1709       
1710          %* Adapted from Mark Terjesons code posted to sas-l:
1710     ! http://www.listserv.uga.edu/cgi-bin/wa?A2=ind0003d&L=sas-l&D=0&P=18578 ;
1711       
1712          %* This defines VarList ;
1713          %GetVarList( Dset = &Lib..&Dset
1714                     , RecStart = &RecStart
1715                     , RecEnd = &RecEnd) ;
1716       
1717          %put VarList is &VarList ;
1718       
1719          %let LastVar = %LastWord(&VarList) ;
1720       
1721          proc sort nodupkey data = &Lib..&Dset ;
1722             by &VarList &RecStart &RecEnd ;
1723          run ;
1724       
34                                                         The SAS System                               17:43 Friday, April 16, 2010

1725          data &Lib..&Dset ;
1726             retain PeriodStart PeriodEnd ;
1727             format PeriodStart PeriodEnd mmddyy10. ;
1728             set &Lib..&Dset(rename = (&RecStart = _&RecStart
1729                                 &RecEnd   = _&RecEnd)) ;
1730             by &VarList ;
1731       
1732             if first.&LastVar then do ;
1733                * Start of a new period--initialize. ;
1734                PeriodStart = _&RecStart ;
1735                PeriodEnd   = _&RecEnd ;
1736                %if &Debug = 1 %then %do ;
1737                   put "First &LastVar:          " _N_ = PeriodStart =  _&RecStart =  PeriodEnd =  _&RecEnd = ;
1738                %end ;
1739             end ;
1740             * else do ;
1741                /*
1742                   Checking "contiguousity":
1743                   If this records start date falls w/in (or butts up against) the
1744                   current period (plus tolerance), then extend the current period out to this
1745                   records end date.
1746                */
1747                * if (PeriodStart <= _&RecStart <= PeriodEnd + 1) then do ;
1748                if (PeriodStart <= _&RecStart <= (PeriodEnd + &DaysTol)) then do ;
1749                   * Extend the period end out to whichever is longer--the period or the record. ;
1750                   PeriodEnd = max(_&RecEnd, PeriodEnd) ;
1751                   %if &Debug = 1 %then %do ;
1752                      put "Extending period end:   " _N_ = PeriodStart =  _&RecStart =  PeriodEnd =  _&RecEnd = ;
1753                   %end ;
1754                end ;
1755                else do ;
1756                   * We are in a new period--output the last rec & reinitialize. ;
1757                   output ;
1758                   PeriodStart = _&RecStart ;
1759                   PeriodEnd   = _&RecEnd ;
1760                end ;
1761             * end ;
1762             /*
1763                Likewise, if this is our last value of the last var on our BY list, we are about to start a new period.
1764                Spit out the record--the new period vars get initialized above in the "if first.&LastVar..."
1765                block.
1766             */
1767             if last.&LastVar then do ;
1768                %if &Debug = 1 %then %do ;
1769                   put "Last &LastVar:           " _N_ = PeriodStart =  _&RecStart =  PeriodEnd =  _&RecEnd = ;
1770                %end ;
1771                output ;
1772             end ;
1773          run ;
1774          * Now we have the actual start/stop dates in PeriodStart & PeriodEnd--rename those to ;
1775          * the original record start/stop variable names, and strip out any wacky recs where start comes after end ;
1776          data &Lib..&Dset ;
1777             set &Lib..&Dset(rename = (PeriodStart = &RecStart
35                                                         The SAS System                               17:43 Friday, April 16, 2010

1778                                 PeriodEnd   = &RecEnd)) ;
1779             * if PeriodStart le PeriodEnd ;
1780             drop _&RecStart _&RecEnd ;
1781          run ;
1782       %mend OLDCollapsePeriods ;
1783       
1784       %macro CollapsePeriods(Lib          /* Name of the library containing the dset you want collapsed */
1785                            , DSet         /* Name of the dset you want collapsed. */
1786                            , RecStart     /* Name of the var that contains the period start dates. */
1787                            , RecEnd       /* Name of the var that contains the period end dates. */
1788                            , PersonID  = MRN   /* Name of the var that contains a unique person identifier. */
1789                            , DaysTol = 1  /* The number of days gap to tolerate in evaluating whether one period is contiguous
1789     ! w/another. */
1790                            , Debug   = 0  /* 0/1 flag indicating whether you want the PUT statements to run (PRODUCES A LOT OF
1790     ! OUTPUT!). */
1791                            ) ;
1792       
1793          %* Takes an input mbhist dataset and collapses contiguous time periods where the variables ;
1794          %* other than the ones defining period start/stop dates dont change. ;
1795       
1796          %* Adapted from Mark Terjesons code posted to sas-l:
1796     ! http://www.listserv.uga.edu/cgi-bin/wa?A2=ind0003d&L=sas-l&D=0&P=18578 ;
1797       
1798          %* This defines VarList ;
1799          %GetVarList( Dset = &Lib..&Dset
1800                     , RecStart = &RecStart
1801                     , RecEnd = &RecEnd
1802                     , PersonID = &PersonID) ;
1803       
1804          %put VarList is &VarList ;
1805       
1806          %put Length of varlist is %length(&varlist) ;
1807       
1808          %if %length(&varlist) = 0 %then %do ;
1809             %let LastVar = &PersonID ;
1810          %end ;
1811          %else %do ;
1812             %let LastVar = %LastWord(&VarList) ;
1813          %end ;
1814       
1815          proc sort nodupkey data = &Lib..&Dset ;
1816             by &PersonID &RecStart &VarList &RecEnd ;
1817          run ;
1818       
1819          data &Lib..&Dset ;
1820             retain PeriodStart PeriodEnd ;
1821             format PeriodStart PeriodEnd mmddyy10. ;
1822             set &Lib..&Dset(rename = (&RecStart = _&RecStart
1823                                       &RecEnd   = _&RecEnd)) ;
1824       
1825             by &PersonID &VarList NOTSORTED ;
1826       
1827             if first.&LastVar then do ;
36                                                         The SAS System                               17:43 Friday, April 16, 2010

1828                * Start of a new period--initialize. ;
1829                PeriodStart = _&RecStart ;
1830                PeriodEnd   = _&RecEnd ;
1831                %if &Debug = 1 %then %do ;
1832                   put "First &LastVar:          " _N_ = PeriodStart =  _&RecStart =  PeriodEnd =  _&RecEnd = ;
1833                %end ;
1834             end ;
1835             * else do ;
1836                /*
1837                   Checking "contiguousity":
1838                   If this records start date falls w/in (or butts up against) the
1839                   current period (plus tolerance), then extend the current period out to this
1840                   records end date.
1841                */
1842                * if (PeriodStart <= _&RecStart <= PeriodEnd + 1) then do ;
1843                if (PeriodStart <= _&RecStart <= (PeriodEnd + &DaysTol)) then do ;
1844                   * Extend the period end out to whichever is longer--the period or the record. ;
1845                   PeriodEnd = max(_&RecEnd, PeriodEnd) ;
1846                   %if &Debug = 1 %then %do ;
1847                      put "Extending period end:   " _N_ = PeriodStart =  _&RecStart =  PeriodEnd =  _&RecEnd = ;
1848                   %end ;
1849                end ;
1850                else do ;
1851                   * We are in a new period--output the last rec & reinitialize. ;
1852                   output ;
1853                   PeriodStart = _&RecStart ;
1854                   PeriodEnd   = _&RecEnd ;
1855                end ;
1856             * end ;
1857             /*
1858                Likewise, if this is our last value of the last var on our BY list, we are about to start a new period.
1859                Spit out the record--the new period vars get initialized above in the "if first.&LastVar..."
1860                block.
1861             */
1862             if last.&LastVar then do ;
1863                %if &Debug = 1 %then %do ;
1864                   put "Last &LastVar:           " _N_ = PeriodStart =  _&RecStart =  PeriodEnd =  _&RecEnd = ;
1865                %end ;
1866                output ;
1867             end ;
1868          run ;
1869          * Now we have the actual start/stop dates in PeriodStart & PeriodEnd--rename those to ;
1870          * the original record start/stop variable names, and strip out any wacky recs where start comes after end ;
1871          data &Lib..&Dset ;
1872             set &Lib..&Dset(rename = (PeriodStart = &RecStart
1873                                 PeriodEnd   = &RecEnd)) ;
1874             * if PeriodStart le PeriodEnd ;
1875             drop _&RecStart _&RecEnd ;
1876          run ;
1877       %mend CollapsePeriods ;
1878       
1879       
1880       %macro GetFollowUpTime(People    /* Dset of MRNs */
37                                                         The SAS System                               17:43 Friday, April 16, 2010

1881                      , IndexDate       /* Name of a date var in &People, or else a
1882                                           date literal, marking the start of the
1883                                           follow-up period. */
1884                      , EndDate         /* Name of a date var in &People, or else a
1885                                           complete date literal, marking the end of
1886                                           the period of interest. */
1887                      , GapTolerance    /* Number of days disenrollment to ignore in
1888                                           deciding the disenrollment date. */
1889                      , CallEndDateVar  /* What name should we give the date var that
1890                                           will hold the end of the f/up period? */
1891                      , OutSet          /* The name of the output dataset. */
1892                      , DebugOut = work /* Libname to save interim dsets to for debugging--leave set to work to discard these.
1892     ! */
1893                      , EnrollDset = __enroll.&_EnrollData /* Supply your own enroll data if you like. */
1894                      , Reverse = 0     /* **(JW 30DEC2009) Look backwards from IndexDate? 1=Reverse */
1895                        ) ;
1896       
1897          %put ;
1898          %put ;
1899          %put ============================================================== ;
1900          %put ;
1901          %put Macro GetFollowUpTime V0.91 (REVISED for Reverse look by JW):  ;
1902          %put ;
1903          %put Creating a dset "&OutSet", which will look just like "&People" except  ;
1904          %put that it will have an additional variable "&CallEndDateVar", which will ;
1905          %put hold the earliest of date-of-last-enrollment, or &EndDate (or, if the  ;
1906          %put person was not enrolled at all a missing value). ;
1907          %put ;
1908          %put THIS IS BETA SOFTWARE-PLEASE SCRUTINIZE THE RESULTS AND REPORT PROBLEMS;
1909          %put ;
1910          %put ============================================================== ;
1911          %put ;
1912          %put ;
1913       
1914       
1915          libname __enroll "&_EnrollLib" access = readonly ;
1916       
1917          proc sql noprint ;
1918       
1919       
1920             %** Grab ENROLL recs for our ppl of interest where the periods overlap the period between &IndexDate and EndDate ;
1921             create table &DebugOut..__enroll as
1922             select p.mrn
1923                   , e.enr_start
1924                   , e.enr_end
1925                   , &IndexDate as idate format = mmddyy10.
1926                   , &EndDate   as edate format = mmddyy10.
1927             from  &People as p INNER JOIN
1928                   &EnrollDset as e
1929             on    p.MRN = e.MRN
1930       
1931             %IF &Reverse.=1 %THEN %DO;
1932             %**(JCW 18FEB2010);
38                                                         The SAS System                               17:43 Friday, April 16, 2010

1933                 where intnx('day', &EndDate.  , -&GapTolerance, 'sameday') <= e.enr_end
1934                   and intnx('day', &IndexDate.,  &GapTolerance, 'sameday') >= e.enr_start
1935             %END;
1936             %ELSE %DO;
1937                 where intnx('day', &IndexDate., -&GapTolerance, 'sameday') <= e.enr_end
1938                   AND intnx('day', &EndDate.  ,  &GapTolerance, 'sameday') >= e.enr_start
1939             %END;
1940       
1941             order by mrn,
1942       
1943             %IF &Reverse.=1 %THEN %DO;
1944             %**(JCW 30DEC2009);
1945                 enr_end DESC
1946             %END;
1947             %ELSE %DO;
1948                 enr_start
1949             %END;
1950       
1951             ;
1952          quit ;
1953       
1954          *** Collapse contiguous periods down. ;
1955          %CollapsePeriods(Lib      = &DebugOut     /* Name of the library containing the dset you want collapsed */
1956                         , DSet     = __enroll      /* Name of the dset you want collapsed. */
1957                         , RecStart = enr_start     /* Name of the var that contains the period start dates. */
1958                         , RecEnd   = enr_end       /* Name of the var that contains the period end dates. */
1959                         , PersonID = MRN
1960                         , DaysTol  = &GapTolerance /* The number of days gap to tolerate in evaluating whether one period is
1960     ! contiguous w/another. */
1961                         ) ;
1962       
1963         ** Handle the (I would hope rare) case where someone is not enrolled on their index ;
1964         ** date, and the start of their enrollment is more than &GapTolerance days away. ;
1965         proc sql ;
1966           delete from &DebugOut..__enroll
1967           %IF &Reverse.=1 %THEN %DO;
1968             where (idate-enr_end) gt &GapTolerance
1969           %END;
1970           %ELSE %DO;
1971             where (enr_start - idate) gt &GapTolerance
1972           %END;
1973           ;
1974         quit ;
1975       
1976       
1977          ** The end of contiguous enrollment is enr_end on the rec w/the earliest enr_start ;
1978          proc sort data = &DebugOut..__enroll out = &DebugOut..__collapsed_enroll ;
1979             by mrn enr_start ;
1980          run ;
1981       
1982          proc sort nodupkey data = &DebugOut..__collapsed_enroll out = &DebugOut..__first_periods ;
1983             by mrn ;
1984          run ;
39                                                         The SAS System                               17:43 Friday, April 16, 2010

1985       
1986          proc sql ;
1987             create table &OutSet as
1988             select p.* ,
1989       
1990             %IF &Reverse.=1 %THEN %DO;
1991             %**(JCW 30DEC2009);
1992               max(e.edate, e.enr_start)
1993             %END;
1994             %ELSE %DO;
1995               min(e.edate, e.enr_end)
1996             %END;
1997             as &CallEndDateVar format = mmddyy10.
1998       
1999             from  &People as p LEFT JOIN
2000                   &DebugOut..__first_periods as e
2001             on    p.mrn = e.mrn
2002             ;
2003          quit ;
2004       
2005       %mend GetFollowUpTime;
2006       
2007       %macro GetRxRiskForPeople(InFile, OutFile, IndexDt);
2008       /*************************************************
2009       * Tyler Ross
2010       * Center for Health Studies
2011       * 206-287-2927
2012       * ross.t@ghc.org
2013       *
2014       * GetRxRiskForPeople.sas
2015       *
2016       * Purpose:
2017       *	Calculates RxRisk comorbidity for a list of MRN. Indicates diseases based on
2018       *   Rx fills.
2019       *
2020       * Notes:
2021       *	This code was based heavily on Jim Savarino's RxRisk macro program
2022       *	written for use at CHS.
2023       *	If enrollment data is not available for the day before IndexDt, the enrollee
2024       *   is assumed to not be on Medicaid nor Medicare.  This is partly because the
2025       *		CRN specs do not distinguish between non-Medicare and missing.
2026       *	Weights are callibrated separately for adults and children. Disease categories
2027       *   in many cases are applicable to only one of these two models. The lable of
2028       *   each disease starts with A if adults only, P if pediatrics only, and AP if
2029       *   both apply.
2030       *
2031       *   Be aware that this macro may take a while depending on the size of your
2032       *     cohort and the size of your data structures.
2033       *
2034       * Dependencies:
2035       *	A series of SAS data files that accompany this program and a libref assigned
2036       *		to the directory they are stored in in StdVars.sas
2037       *   (%let _RxRiskLib="\\DIRECTORY";).
40                                                         The SAS System                               17:43 Friday, April 16, 2010

2038       *	StdVars.sas--the site-customized list of standard macro variables.
2039       *	The following variables from the following data structures
2040       *			Demographics: MRN, Birth_Date, Gender  (All required)
2041       *			Enrollment: MRN, Ins_Medicare, Ins_Medicaid (Not required)
2042       *			Pharmacy: MRN, RxDate, NDC (Required)
2043       *
2044       *			****************************************************
2045       *			***IMPORTANT***IMPORTANT***IMPORTANT***IMPORTANT****
2046       *
2047       *			The Pharmacy file must have all fills one year prior
2048       *			to the index date for each enrollee for the results
2049       *			to be accurate!
2050       *
2051       *			***IMPORTANT***IMPORTANT***IMPORTANT***IMPORTANT****
2052       *			****************************************************
2053       *
2054       * Inputs:
2055       *	A file with variables MRN and &IndexDt to calculate RxRisk.
2056       *
2057       * Output:
2058       *	A file with 52 variables:
2059       *		MRN
2060       *		RxRisk = The RxRisk estimate of MRN's expenditures for the year
2061       *					starting on IndexDt
2062       *		Model = The model used to calculate RxRisk
2063       *					A = Adult
2064       *					P = Pediatric
2065       *		49 Diseases = Series of disease dummies based on Rx fills
2066       *
2067       * Parameters:
2068       *	&InFile  = The name of a file with distinct MRN
2069       *	&OutFile = The name of the file that will be outputted
2070       *	&IndexDt = The variable that holds the first day of the year's expenditures
2071       *              that you want to estimate for each individual (i.e. the date on
2072       *			         which to calculate the comorbidity.
2073       *
2074       * Version History
2075       *
2076       *	Created:	01/17/2006
2077       *	Modified:	03/28/2006
2078       *		- Added disease-specific sub-categories for adults & children.
2079       * Modified: 10/20/2006
2080       *   - Adjusted enrollment merge to match new enrollment specs
2081       * Modified 3/24/2009 [RP]
2082       *   - Fixed some of the joins so that this will run on sas 9.2.
2083       *   - Prettied up some of the code
2084       *   - Made the CondCodes{i} comparison literals text so this will run w/dsoptions="note2err".
2085       *
2086       * Users of RxRisk should cite these two papers, on which the work is based:
2087       *
2088       * Paul A. Fishman, Michael Goodman, Mark Hornbrook, Richard Meenan, Don Bachman,
2089       *   Maureen OKeefe Rossetti, "Risk Adjustment Using Automated Pharmacy Data:
2090       *   the RxRisk Model," Medical Care 2003;41:84-99
41                                                         The SAS System                               17:43 Friday, April 16, 2010

2091       *
2092       * Paul Fishman and David Shay,
2093       * "A Pediatric Chronic Disease Score from Automated Pharmacy Data",
2094       *    Medical Care, 1999,37(9) pp 872-880.
2095       *
2096       *************************************************/
2097       
2098       	%LET adultage=18;
2099       	/*This limits the maximum number of different diseases a person can have*/
2100       	%LET MaxDisease=20;
2101       
2102       	libname dem "&_DemographicLib.";
2103       	libname enr "&_EnrollLib.";
2104       	libname rx "&_RxLib.";
2105       	libname risk "&_RxRiskLib.";
2106       
2107       	/*Get the Cases file ready*/
2108       	proc sql;
2109       	/*Add on gender and age from demographics*/
2110       	create table GrabDem as
2111       	select 	distinct i.mrn
2112       			, &IndexDt.
2113       			, coalesce(ifn(upcase(d.gender)="M", 0, .),
2114       			           ifn(upcase(d.gender)="F", 1, .)) as gender
2115       			, floor((intck('month',d.Birth_Date,&IndexDt.)
2116       				- (day(&IndexDt.) < day(d.Birth_Date))) / 12) as age
2117       	from &infile. as i
2118       		LEFT JOIN
2119       		 dem.&_DemographicData. as d
2120       	on i.MRN = d.MRN
2121       	;
2122       
2123       	/*Add on Medicare and Medicaid from enrollment*/
2124       	create table Cases as
2125       	select 	  g.*
2126       			, ifn(upcase(e.Ins_Medicare)="Y", 1, 0, 0) as Medicare
2127       			, ifn(upcase(e.Ins_Medicaid)="Y", 1, 0, 0) as Medicaid
2128       	from GrabDem as g
2129       		INNER JOIN
2130       		 enr.&_EnrollData. as e
2131       	on g.MRN = e.MRN
2132       	where &IndexDt. between e.Enr_Start and e.Enr_End
2133       	;
2134       
2135       	/*Get the drug file ready*/
2136       	create table drugs as
2137       	select    distinct i.mrn
2138       			, i.&IndexDt.
2139       			, r.RxDate
2140       			, r.NDC
2141       	from &infile as i
2142       			LEFT JOIN
2143       		 rx.&_RxData. as r
42                                                         The SAS System                               17:43 Friday, April 16, 2010

2144           on    i.MRN = r.MRN
2145           where r.RxDate BETWEEN (&IndexDt.-366) AND (&IndexDt.-1) ;
2146       
2147       	/* Attach a cost for age, adult model  */
2148         create table adult_cost_age_lookup as
2149         select a.code
2150             , c.cost
2151             , a.ageinclusive as age_lowbound
2152             , a.ageexclusive - 1 as age_highbound
2153             , a.female as gender
2154         from  risk.adultageclassification as a INNER JOIN
2155               risk.adultcostcoefficient as c
2156         on    a.code = c.code
2157         where age_lowbound ge &adultage
2158         ;
2159       
2160         create table adultcost as
2161         select  c.*
2162               , l.code
2163               , l.cost
2164               , 'A' as model
2165         from cases as c INNER JOIN
2166              adult_cost_age_lookup as l
2167         on   c.gender = l.gender
2168         WHERE c.age BETWEEN l.age_lowbound and l.age_highbound
2169         ORDER BY c.mrn
2170         ;
2171       
2172         drop table adult_cost_age_lookup ;
2173       
2174         /*
2175       	create table adultcost as
2176       	select    T1.*
2177           			, T2.code
2178           			, T3.cost
2179           			,'A' as Model
2180       	from  risk.adultcostcoefficient as T3
2181       		, Cases as T1 inner join risk.adultageclassification as T2
2182       	on t3.code=t2.code
2183       	where T1.age >= &adultage and T2.female=T1.gender and
2184       		 (T1.age >= T2.ageinclusive and T1.age < T2.ageexclusive)
2185       	order by MRN;
2186         */
2187       
2188       	/* Attach a cost for age, pediatric model  */
2189         create table child_cost_age_lookup as
2190         select a.code
2191             , c.cost
2192             , a.ageinclusive as age_lowbound
2193             , a.ageexclusive - 1 as age_highbound
2194             , a.female as gender
2195         from  risk.childageclassification as a INNER JOIN
2196               risk.childcostcoefficient as c
43                                                         The SAS System                               17:43 Friday, April 16, 2010

2197         on    a.code = c.code
2198         where age_lowbound lt &adultage
2199         ;
2200       
2201         create table pedcost as
2202         select  c.*
2203               , l.code
2204               , l.cost
2205               , 'P' as model
2206         from cases as c INNER JOIN
2207              child_cost_age_lookup as l
2208         on   c.gender = l.gender
2209         WHERE c.age BETWEEN l.age_lowbound and l.age_highbound
2210         ORDER BY c.mrn
2211         ;
2212       
2213         drop table child_cost_age_lookup ;
2214       
2215         /*
2216       	create table pedcost as
2217       	select 	  T1.*
2218       			, T2.code
2219       			, T3.cost
2220       			, 'P' as Model
2221       	from risk.childcostcoefficient as T3
2222       		, Cases as T1 inner join risk.childageclassification as T2
2223       	on t3.code=t2.code
2224       	where T1.age < &adultage and T2.female=T1.gender and
2225       		(T1.age >= T2.ageinclusive and T1.age < T2.ageexclusive)
2226       	order by MRN
2227       	;
2228         */
2229       
2230       
2231       	/* For adult model , compute a cost factor for Medicare  */
2232       	create table adult_medicare_lookup as
2233         select a.code
2234             , c.cost
2235             , a.ageinclusive as age_lowbound
2236             , a.ageexclusive - 1 as age_highbound
2237         from  risk.medicareclassification as a INNER JOIN
2238               risk.adultcostcoefficient as c
2239         on    a.code = c.code
2240         ;
2241       
2242         create table carecost as
2243         select  c.*
2244               , l.code
2245               , l.cost
2246               , 'A' as model
2247         from cases as c INNER JOIN
2248              adult_medicare_lookup as l
2249         on    c.medicare = 1 AND
44                                                         The SAS System                               17:43 Friday, April 16, 2010

2250               c.age ge &adultage AND
2251               c.age BETWEEN l.age_lowbound and l.age_highbound
2252         ORDER BY c.mrn
2253         ;
2254       
2255         drop table adult_medicare_lookup ;
2256       
2257         /*
2258       	create table carecost as
2259       	select 	  T1.*
2260       			, T2.code
2261       			, T3.cost
2262       			,'A' as Model
2263       	from risk.adultcostcoefficient as T3
2264       		, Cases as T1 inner join risk.medicareclassification as T2
2265       	on t3.code=t2.code
2266       	where (T1.age >= T2.ageinclusive and T1.age < T2.ageexclusive)
2267       		and (T1.age >= &adultage ) and (T1.medicare=1)
2268       	order by MRN
2269       	;
2270         */
2271       
2272       	/* For adult, compute a cost factor for Medicaid when present  */
2273       	create table medicaid_lookup as
2274         select a.code
2275             , c.cost
2276             , a.ageinclusive as age_lowbound
2277             , a.ageexclusive - 1 as age_highbound
2278         from  risk.medicaidclassification as a INNER JOIN
2279               risk.adultcostcoefficient as c
2280         on    a.code = c.code
2281         ;
2282       
2283         create table caidcost as
2284         select  c.*
2285               , l.code
2286               , l.cost
2287               , 'A' as model
2288         from cases as c INNER JOIN
2289              medicaid_lookup as l
2290         on    c.medicaid = 1 AND
2291               c.age ge &adultage AND
2292               c.age BETWEEN l.age_lowbound and l.age_highbound
2293         ORDER BY c.mrn
2294         ;
2295       
2296         /*
2297       	create table caidcost as
2298       	select 	  T1.*
2299       			, T2.code
2300       			, T3.cost
2301       			, 'A' as Model
2302       	from risk.adultcostcoefficient T3,
45                                                         The SAS System                               17:43 Friday, April 16, 2010

2303       		Cases as T1 inner join risk.medicaidclassification as T2
2304       	on t3.code=t2.code
2305       	where (T1.age >= T2.ageinclusive and T1.age < T2.ageexclusive)
2306       		and (T1.age >= &adultage ) and (T1.medicaid=1)
2307       	order by MRN;
2308       
2309         */
2310       
2311       	/* For pediatric model, compute a cost factor for Medicaid when present  */
2312       
2313         create table caidchld as
2314         select  c.*
2315               , l.code
2316               , l.cost
2317               , 'A' as model
2318         from  cases as c INNER JOIN
2319               medicaid_lookup as l
2320         on    c.medicaid = 1 AND
2321               c.age lt &adultage AND
2322               c.age BETWEEN l.age_lowbound and l.age_highbound
2323         ORDER BY c.mrn
2324         ;
2325       
2326         drop table medicaid_lookup ;
2327       
2328       	/* Rebuild case information with age cost factor and medicare cost added */
2329       	data caseinfo;
2330         		set adultcost pedcost;
2331         		by mrn;
2332       	run;
2333       
2334       	/* Drop working tables to free disk space */
2335       	proc sql;
2336       		drop table adultcost;
2337       		drop table pedcost;
2338       
2339       	/* Screen out any medications not within time window  */
2340       	create table workmeds as
2341       	select 	  T1.*
2342       			, T2.age
2343       	from drugs as T1 INNER JOIN caseinfo as T2
2344       	on T2.MRN=T1.MRN
2345       	where ( (T2.&IndexDt.-T1.RxDate) > 0 ) AND ( (T2.&IndexDt.-T1.RxDate) <= 365 )
2346       	;
2347       
2348       	/* Attach a cost coefficient to each medication, adult model  */
2349       	create table work1 as
2350       	select	  T1.*
2351       			, T2.code
2352       			, T3.cost
2353       			, 'A' as Model
2354       	from risk.adultcostcoefficient as T3
2355       		, workmeds as T1 inner join risk.adultdrugclassification as T2
46                                                         The SAS System                               17:43 Friday, April 16, 2010

2356       	on t2.ndccode=t1.ndc
2357       	where t3.code=t2.code AND T1.age >= &adultage
2358       	;
2359       
2360       	/* Attach a cost coefficient to each medication, pediatric model */
2361       	create table work2 as
2362       	select 	  T1.*
2363       			, T2.code
2364       			, T3.cost
2365       			, 'P' as Model
2366       	from risk.childcostcoefficient as T3
2367       		, workmeds as T1 inner join risk.childdrugclassification as T2
2368       	on t2.ndccode=t1.ndc
2369       	where t3.code=t2.code AND T1.age < &adultage
2370       	;
2371       
2372       	proc sql;  drop table workmeds; quit;
2373       
2374       	/* Now remove duplicate cost classifications at case id level
2375         	   for adults. Sorting separately to reduce cost of sort...
2376       	*/
2377       	%let byvars=mrn code;
2378       	proc sort data=work1 nodupkey; by &byvars; run;
2379       
2380       	/* Now remove duplicate cost classifications at case id level for children*/
2381       	proc sort data=work2 nodupkey; by &byvars; run;
2382       
2383       	/* Now produce file with rxrisk outcome */
2384       	%let keepvars=MRN Model cost;
2385       	data work3(keep=MRN model cost);
2386          		set work1(keep=&keepvars)
2387                 work2(keep=&keepvars)
2388       			caseinfo(keep=&keepvars)
2389       			carecost(keep=&keepvars)
2390       			caidcost(keep=&keepvars)
2391       			caidchld(keep=&keepvars);
2392       	run;
2393       
2394       	proc sql;
2395       		drop table work1;
2396       		drop table work2;
2397       		drop table carecost;
2398       		drop table caidcost;
2399       		drop table caidchld;
2400       
2401       	/*Create Rx Variable*/
2402       	create table work4 as
2403       	select 	  MRN
2404       			, sum(cost) as rxrisk
2405       			, model
2406       	from work3
2407       	group by MRN, model
2408       	;
47                                                         The SAS System                               17:43 Friday, April 16, 2010

2409       	drop table work3;
2410       
2411       	/*****************************************************
2412       	* Modification to add disease indicators starts here *
2413       	*****************************************************/
2414       
2415       	/*Add codes for children*/
2416       	create table DiseaseKids as
2417       	select a.mrn, B.code, c.age
2418       	from drugs as a, risk.childdrugclassification as B, GrabDem as c
2419       	where a.ndc=B.ndccode AND a.mrn=c.mrn AND (0<=c.age<&adultage.)
2420       	;
2421       	/*Add codes for adults*/
2422       	create table DiseaseAll as
2423       	select a.mrn, B.code, c.age
2424       	from drugs as a, risk.adultdrugclassification as B, GrabDem as c
2425       	where a.ndc=B.ndccode AND a.mrn=c.mrn AND c.age>=&adultage.
2426       	;
2427       	quit;
2428       	/*Combine kids and adults*/
2429       	proc append base=DiseaseAll data=DiseaseKids; run;
2430       
2431       	/*Keep first instance of each disease*/
2432       	proc sort data=DiseaseAll nodupkey; by mrn code; run;
2433       
2434         proc sort data=DiseaseAll; by mrn age; run;
2435       
2436       	proc transpose data=DiseaseAll out=DiseaseAll prefix=CondCode;
2437       		var code;
2438       		by mrn age;
2439       	run;
2440       
2441         %local flag_names ;
2442         %let flag_names = Acne Allerg Alpha Amino Anxiety Asthma ADD Bipolar CAD
2443                       		CLS CAH PRV CF Dep Dm2 Eczema Epi ESRD GAD Glaucoma Gout
2444                       		GHD HD Hemophilia HIV Hyperlip HTN Immunod Iron IBS Lead
2445                       		Liver Malabs Malig Ostomy Pain Inflame Parkin Pituitary
2446                       		Psych Renal RDS RA Sickle	Steroid Thyroid Trache
2447                       		Transplant TB ;
2448       
2449       	/*Assign diseases*/
2450       	data DiseaseAll (keep=mrn Acne--TB) ;
2451       		set DiseaseAll;
2452       		length &flag_names 3 ;
2453       
2454       		array Conds{*} &flag_names ;
2455       
2456       		do i = 1 to dim(Conds);
2457          			Conds{i} = 0;
2458       		end;
2459       
2460       		array CondCodes{*} CondCode1-CondCode&MaxDisease.;
2461       
48                                                         The SAS System                               17:43 Friday, April 16, 2010

2462       		do i = 1 to dim(CondCodes);
2463       			if CondCodes{i} 	   = '1' & age<&adultage.   then Acne       =1 ;
2464       			else if CondCodes{i} = '2' & age<&adultage. 	then Allerg     =1 ;
2465       			else if CondCodes{i} = '3' & age<&adultage. 	then Alpha      =1 ;
2466       			else if CondCodes{i} = '4' & age<&adultage. 	then Amino      =1 ;
2467          		else if CondCodes{i} = '5'  					        then Anxiety    =1 ;
2468          		else if CondCodes{i} = '6'  					        then Asthma     =1 ;
2469       			else if CondCodes{i} = '7' & age<&adultage. 	then ADD        =1 ;
2470          		else if CondCodes{i} = '8'  					        then Bipolar    =1 ;
2471          	  else if CondCodes{i} = '9'  					        then CAD        =1 ;
2472       			else if CondCodes{i} = '10' & age<&adultage. 	then CLS        =1 ;
2473       			else if CondCodes{i} = '11' & age<&adultage.	then CAH        =1 ;
2474       			else if CondCodes{i} = '12' & age>=&adultage.	then PRV        =1 ;
2475       			else if CondCodes{i} = '13' 					        then CF         =1 ;
2476       			else if CondCodes{i} = '14' 					        then Dep        =1 ;
2477       			else if CondCodes{i} = '15' 					        then Dm2        =1 ;
2478       			else if CondCodes{i} = '16' & age<&adultage.	then Eczema     =1 ;
2479       			else if CondCodes{i} = '17' 					        then Epi        =1 ;
2480       			else if CondCodes{i} = '18' & age>=&adultage.	then ESRD       =1 ;
2481       			else if CondCodes{i} = '19' 					        then GAD        =1 ;
2482       			else if CondCodes{i} = '20' & age>=&adultage.	then Glaucoma   =1 ;
2483       			else if CondCodes{i} = '21' & age>=&adultage.	then Gout       =1 ;
2484       			else if CondCodes{i} = '22' & age<&adultage.	then GHD        =1 ;
2485       			else if CondCodes{i} = '23' & age>=&adultage.	then HD         =1 ;
2486       			else if CondCodes{i} = '24' & age<&adultage.	then Hemophilia =1 ;
2487       			else if CondCodes{i} = '25' 					        then HIV        =1 ;
2488       			else if CondCodes{i} = '26' 					        then Hyperlip   =1 ;
2489       			else if CondCodes{i} = '27' & age>=&adultage.	then HTN        =1 ;
2490       			else if CondCodes{i} = '28' & age<&adultage.	then Immunod    =1 ;
2491       			else if CondCodes{i} = '29' & age<&adultage.	then Iron       =1 ;
2492       			else if CondCodes{i} = '30' 					        then IBS        =1 ;
2493       			else if CondCodes{i} = '31' & age<&adultage.	then Lead       =1 ;
2494       			else if CondCodes{i} = '32' 					        then Liver      =1 ;
2495       			else if CondCodes{i} = '33' & age<&adultage.	then Malabs     =1 ;
2496       			else if CondCodes{i} = '34' 					        then Malig      =1 ;
2497       			else if CondCodes{i} = '35' & age<&adultage.	then Ostomy     =1 ;
2498       			else if CondCodes{i} = '36' & age<&adultage.	then Pain       =1 ;
2499       			else if CondCodes{i} = '37' & age<&adultage.	then Inflame    =1 ;
2500       			else if CondCodes{i} = '38' & age>=&adultage.	then Parkin     =1 ;
2501       			else if CondCodes{i} = '39' & age<&adultage.	then Pituitary  =1 ;
2502       			else if CondCodes{i} = '40' 					        then Psych      =1 ;
2503       			else if CondCodes{i} = '41' 					        then Renal      =1 ;
2504       			else if CondCodes{i} = '42' & age<&adultage.	then RDS        =1 ;
2505          		else if CondCodes{i} = '43' 					        then RA         =1 ;
2506       			else if CondCodes{i} = '44' & age<&adultage.	then Sickle     =1 ;
2507       			else if CondCodes{i} = '45' & age<&adultage.	then Steroid    =1 ;
2508       			else if CondCodes{i} = '46' 					        then Thyroid    =1 ;
2509       			else if CondCodes{i} = '47' & age<&adultage.	then Trache     =1 ;
2510       			else if CondCodes{i} = '48' 					        then Transplant =1 ;
2511          		else if CondCodes{i} = '49' 					        then TB         =1 ;
2512       		end;
2513       	run;
2514       
49                                                         The SAS System                               17:43 Friday, April 16, 2010

2515          proc sql;
2516          /*Create Output File*/
2517          create table &outfile as
2518          select a.MRN
2519                , a.rxrisk                                   label ='RxRisk Comorbidity'
2520                , a.model                                    label ='Adult vs Pediatric Model'
2521                , coalesce(b.Acne        , 0) as Acne        label ='P1 Acne'                            length=3
2522                , coalesce(b.Allerg      , 0) as Allerg      label ='P2 Allergic Rhinitis'               length=3
2523                , coalesce(b.Alpha       , 0) as Alpha       label ='P3 Alpha'                           length=3
2524                , coalesce(b.Amino       , 0) as Amino       label ='P4 Amino Acid Disorders'            length=3
2525                , coalesce(b.Anxiety     , 0) as Anxiety     label ='AP5 Anxiety and Tension'            length=3
2526                , coalesce(b.Asthma      , 0) as Asthma      label ='AP6 Asthma'                         length=3
2527                , coalesce(b.ADD         , 0) as ADD         label ='P7 Attention Deficit Disorder'      length=3
2528                , coalesce(b.Bipolar     , 0) as Bipolar     label ='AP8 Bipolar Disorder'               length=3
2529                , coalesce(b.CAD         , 0) as CAD         label ='AP9 Cardiac Disease'                length=3
2530                , coalesce(b.CLS         , 0) as CLS         label ='P10 Central Line Supplies'          length=3
2531                , coalesce(b.CAH         , 0) as CAH         label ='P11 Congenital Adrenal Hypoplasia'  length=3
2532                , coalesce(b.PRV         , 0) as PRV         label ='A12 Coronary/Peripheral Vasc'       length=3
2533                , coalesce(b.CF          , 0) as CF          label ='AP13 Cystic Fibrosis'               length=3
2534                , coalesce(b.Dep         , 0) as Dep         label ='AP14 Depression'                    length=3
2535                , coalesce(b.Dm2         , 0) as Dm2         label ='AP15 Diabetes'                      length=3
2536                , coalesce(b.Eczema      , 0) as Eczema      label ='P16 Eczema'                         length=3
2537                , coalesce(b.Epi         , 0) as Epi         label ='AP17 Epilepsy'                      length=3
2538                , coalesce(b.ESRD        , 0) as ESRD        label ='A18 ESRD'                           length=3
2539                , coalesce(b.GAD         , 0) as GAD         label ='AP19 Gastric Acid Disorder'         length=3
2540                , coalesce(b.Glaucoma    , 0) as Glaucoma    label ='A20 Glaucoma'                       length=3
2541                , coalesce(b.Gout        , 0) as Gout        label ='A21 Gout'                           length=3
2542                , coalesce(b.GHD         , 0) as GHD         label ='P22 Growth Hormone Deficiency'      length=3
2543                , coalesce(b.HD          , 0) as HD          label ='A23 Heart Disease/Hypertension'     length=3
2544                , coalesce(b.Hemophilia  , 0) as Hemophilia  label ='P24 Hemophilia'                     length=3
2545                , coalesce(b.HIV         , 0) as HIV         label ='AP25 HIV'                           length=3
2546                , coalesce(b.Hyperlip    , 0) as Hyperlip    label ='AP26 Hyperlipidemia'                length=3
2547                , coalesce(b.HTN         , 0) as HTN         label ='A27 Hypertension'                   length=3
2548                , coalesce(b.Immunod     , 0) as Immunod     label ='P28 Immunodeficiency'               length=3
2549                , coalesce(b.Iron        , 0) as Iron        label ='P29 Iron Overload'                  length=3
2550                , coalesce(b.IBS         , 0) as IBS         label ='AP30 Irritable Bowel Syndrome'      length=3
2551                , coalesce(b.Lead        , 0) as Lead        label ='P31 Lead Poisoning'                 length=3
2552                , coalesce(b.Liver       , 0) as Liver       label ='AP32 Liver Disease'                 length=3
2553                , coalesce(b.Malabs      , 0) as Malabs      label ='P33 Malabsorbtion'                  length=3
2554                , coalesce(b.Malig       , 0) as Malig       label ='AP34 Malignancies'                  length=3
2555                , coalesce(b.Ostomy      , 0) as Ostomy      label ='P35 Ostomy'                         length=3
2556                , coalesce(b.Pain        , 0) as Pain        label ='P36 Pain'                           length=3
2557                , coalesce(b.Inflame     , 0) as Inflame     label ='P37 Pain and Inflammation'          length=3
2558                , coalesce(b.Parkin      , 0) as Parkin      label ='A38 Parkinsons Disease'             length=3
2559                , coalesce(b.Pituitary   , 0) as Pituitary   label ='P39 Pituitary Hormone'              length=3
2560                , coalesce(b.Psych       , 0) as Psych       label ='AP40 Psychotic Illness'             length=3
2561                , coalesce(b.Renal       , 0) as Renal       label ='AP41 Renal Disease'                 length=3
2562                , coalesce(b.RDS         , 0) as RDS         label ='P42 Respiratory Distriess Syndrome' length=3
2563                , coalesce(b.RA          , 0) as RA          label ='AP43 Rheumatoid Arthritis'          length=3
2564                , coalesce(b.Sickle      , 0) as Sickle      label ='P44 Sickle Cell Anemia'             length=3
2565                , coalesce(b.Steroid     , 0) as Steroid     label ='P45 Steroid Dependent Disease'      length=3
2566                , coalesce(b.Thyroid     , 0) as Thyroid     label ='AP46 Thyroid Disorder'              length=3
2567                , coalesce(b.Trache      , 0) as Trache      label ='P47 Tracheostomy'                   length=3
50                                                         The SAS System                               17:43 Friday, April 16, 2010

2568                , coalesce(b.Transplant  , 0) as Transplant  label ='AP48 Transplant'                    length=3
2569                , coalesce(b.TB          , 0) as TB          label ='AP49 Tuberculosis'                  length=3
2570          from work4 as a
2571             LEFT JOIN
2572              DiseaseAll as b
2573          on a.mrn=b.mrn
2574          ;
2575       
2576       	drop table work4;
2577       	quit;
2578       %mend GetRxRiskForPeople;
2579       
2580       %macro PrettyVar(VarName) ;
2581          %let __allups = %str('Po', 'Ne', 'Nw', 'Se', 'Sw', 'N.e.', 'N.w.', 'S.e.'
2582                             , 'S.w.', 'C/o', 'P.o.', 'P.o', 'Ii', 'Iii', 'Iv', 'Mlk', 'Us') ;
2583          %let __4thUps = %str('Maccoll', 'Maccubbin', 'Macdonald', 'Macdougall'
2584                             , 'Macgregor', 'Macintyre', 'Mackenzie', 'Macmenigall'
2585                             , 'Macneil', 'Macneill') ;
2586          %* These signify apartment numbers like #3A ;
2587          %let __upprefixes = %str('#', '1', '2', '3', '4'
2588                                 , '5', '6', '7', '8', '9', '0') ;
2589       
2590          %let __delims = " -'." ;
2591       
2592          __i            = 0 ;
2593          __word         = '~' ;
2594          __pretty_var   = '' ;
2595          __propcased    = propcase(&VarName, &__delims) ;
2596       
2597          * We have had a lot of backticks & double-quotes in our address components at GHC. ;
2598          __propcased    = compress(__propcased, '`"') ;
2599       
2600          do while (__word ne '') ;
2601             * put __word = ;
2602             __i + 1 ;
2603       
2604             * This will eat any delimiters other than the space char. ;
2605             __word = scan(__propcased, __i, " ")  ;
2606       
2607             %* TODO: Apply address-word-regularizing format to __word here. ;
2608       
2609             if __word in(&__allups) then do ;
2610                __word = upcase(__word) ;
2611             end ;
2612       
2613             if __word in(&__4thUps) then do ;
2614                substr(__word, 4, 1) = upcase(substr(__word, 4, 1)) ;
2615             end ;
2616       
2617             * Try out upcasing the 3rd char for any word beginning with Mc ;
2618             if substr(__word, 1, 2) = 'Mc' then do ;
2619                substr(__word, 3, 1) = upcase(substr(__word, 3, 1)) ;
2620             end ;
51                                                         The SAS System                               17:43 Friday, April 16, 2010

2621       
2622             * Pound symbols signify apt. numbers--upcase those. ;
2623             /* if substr(__word, 1, 1) in (&__upprefixes)
2624                 and reverse(substr(reverse(compress(__word)), 1, 2))
2625                     not in (&__downsuffixes) then do ; */
2626             if substr(__word, 1, 1) in (&__upprefixes)  then do ;
2627                if prxmatch(__ordinal_regex, __word) > 0 then do ;
2628                   * This is a 22nd, 34th type thing--leave it alone ;
2629                end ;
2630                else do ;
2631                   * This is most likely an apartment number--upcase it. ;
2632                   __word = upcase(__word) ;
2633                end ;
2634             end ;
2635       
2636             __pretty_var = compbl(__pretty_var || __word || ' ') ;
2637       
2638          end ;
2639       
2640          &VarName = left(__pretty_var) ;
2641       
2642       %mend PrettyVar ;
2643       
2644       %macro PrettyCase(InSet = , OutSet = , VarList = , MaxLength = 500) ;
2645          data &OutSet ;
2646             length __word __propcased __pretty_var $ &MaxLength ;
2647             retain __ordinal_regex ;
2648             set &InSet ;
2649             if _n_ = 1 then do ;
2650                %* This matches things like 21st, 5th, etc. ;
2651                __ordinal_regex = prxparse("/\d+(st|nd|rd|th)/i") ;
2652             end ;
2653             %let i = 0 ;
2654             %let ThisVar = ~ ;
2655             %do %until(%length(&ThisVar) = 0) ;
2656                %let i = %eval(&i + 1) ;
2657                %let ThisVar = %scan(&VarList, &i) ;
2658                %put Working on &ThisVar %length(&ThisVar) ;
2659                %if %length(&ThisVar) gt 0 %then %do ;
2660                   %PrettyVar(VarName = &ThisVar) ;
2661                %end ;
2662             %end ;
2663       
2664             drop __: ;
2665          run ;
2666       %mend PrettyCase ;
2667       
2668       %macro GetCensusForPeople(InSet = , OutSet = , CensusYear = 2000) ;
2669          libname __census "&_CensusLib." access = readonly ;
2670          proc sql ;
2671             create table &OutSet (drop = _mrn) as
2672             select *
2673             from  &InSet as i LEFT JOIN
52                                                         The SAS System                               17:43 Friday, April 16, 2010

2674                   __census.&_CensusData.&CensusYear (rename = (mrn = _mrn)) as c
2675             on    i.mrn = c._mrn
2676             ;
2677          quit ;
2678          libname __census clear ;
2679       %mend GetCensusForPeople ;
2680       
2681       %macro CleanRx(OutLib, Clean=N, Dirty=N, Report=Y);
2682       /***************************************************************************
2683       * Parameters:
2684       *   OutLib  = The library name you've already declared where you want output
2685       *             you elect to save (Clean="Y", Dirty="Y") to go.
2686       *   Clean   = "Y" will output a table (in OutLib) with Rx fills deemed clean.
2687       *             Any other value will not output this table.
2688       *   Dirty   = "Y" will output a table (in Outlib) with Rx fills deemed dirty.
2689       *             along with DirtyReason, a text variable explaining why the record
2690       *             is dirty.  Any other value will not output this file.
2691       *   Report  = "Y" will do a freq tabulation on the dirty data by DirtyReason,
2692       *             report misspecified variable lengths, and perform freq tables on
2693       *             the clean data.
2694       *             Any other value will suppress this calculation.
2695       *
2696       * Programmer:
2697       *   Tyler Ross
2698       *   Center For Health Studies
2699       *   (206) 287-2927
2700       *   ross.t@ghc.org
2701       *
2702       * History:
2703       *   Created August 1, 2006
2704       **************************************************************************/
2705       
2706         /*Catch Errors*/
2707         %if &Clean ^= Y AND &Dirty ^= Y AND &Report ^= Y %then %do;
2708           %put ERROR: YOU MUST SPECIFY AT LEAST ONE TABLE TO OUTPUT OR TO PRODUCE;
2709           %put ERROR: A REPORT. SET <<CLEAN>>, <<DIRTY>>, AND/OR <<REPORT>> TO "Y";
2710         %end;
2711         %else %do;
2712           /*This mess is so that we save a little IO time depending on whether
2713             programmer wants the datasets saved.*/
2714           %if &Report ^= Y AND &Clean ^= Y %then %do;
2715             %let DataStatement = &OutLib..Dirty;
2716             %let DirtyReturn   = output &Outlib..dirty;
2717             %let CleanReturn   = ;
2718           %end;
2719           %else %if &Report ^= Y AND &Dirty ^= Y %then %do;
2720             %let DataStatement = &OutLib..Clean (drop=DirtyReason);
2721             %let DirtyReturn = ;
2722             %let CleanReturn = output &Outlib..clean;
2723           %end;
2724           %else %if &Report = Y AND &Clean ^= Y AND &Dirty ^= Y %then %do;
2725             %let DataStatement = Clean (drop=DirtyReason) Dirty;
2726             %let DirtyReturn = output dirty;
53                                                         The SAS System                               17:43 Friday, April 16, 2010

2727             %let CleanReturn = output clean;
2728           %end;
2729           %else %if &Report = Y AND &Clean = Y AND &Dirty ^= Y %then %do;
2730             %let DataStatement = &Outlib..Clean (drop=DirtyReason) Dirty;
2731             %let DirtyReturn = output dirty;
2732             %let CleanReturn = output &Outlib..clean;
2733           %end;
2734           %else %if &Report = Y AND &Clean ^= Y AND &Dirty = Y %then %do;
2735             %let DataStatement = Clean (drop=DirtyReason) &Outlib..Dirty;
2736             %let DirtyReturn = output &Outlib..dirty;
2737             %let CleanReturn = output clean;
2738           %end;
2739           %else %do; /*They want both clean and dirty, regardless of report*/
2740             %let DataStatement = &Outlib..Clean (drop=DirtyReason) &Outlib..Dirty;
2741             %let DirtyReturn = output &Outlib..dirty;
2742             %let CleanReturn = output &Outlib..clean;
2743           %end;
2744       
2745           /*Clean the data*/
2746           libname vdwrx "&_RxLib." access=readonly;
2747           proc sort data=vdwrx.&_RxData out=ToClean;
2748             by mrn rxdate ndc;
2749           run;
2750       
2751           data &DataStatement;
2752             set ToClean;
2753             by mrn rxdate ndc;
2754             length DirtyReason $30;
2755       
2756             if MISSING(MRN)=1 then do;
2757               DirtyReason = "Missing MRN";
2758               &DirtyReturn;
2759             end;
2760             else if MISSING(RxDate)=1 then do;
2761               DirtyReason = "Missing RxDate";
2762               &DirtyReturn;
2763             end;
2764             else if MISSING(NDC)=1 then do;
2765               DirtyReason = "Missing NDC";
2766               &DirtyReturn;
2767             end;
2768             else if rxdate > "&Sysdate."d then do;
2769               DirtyReason = "Dispense date in the future";
2770               &DirtyReturn;
2771             end;
2772             else if length(NDC) ^= 11 then do;
2773               DirtyReason = "NDC is improper length";
2774               &DirtyReturn;
2775             end;
2776             else if length(compress(NDC,'1234567890', 'k')) ^= 11 then do;
2777               DirtyReason = "NDC has non numeric values";
2778               &DirtyReturn;
2779             end;
54                                                         The SAS System                               17:43 Friday, April 16, 2010

2780             else if (MISSING(RxSup)=0 AND RxSup <= 0) then do;
2781               DirtyReason = "RxSup is non-positive";
2782               &DirtyReturn;
2783             end;
2784             else if (MISSING(RxAmt)=0 AND RxAmt <= 0) then do;
2785               DirtyReason = "RxAmt is non-positive";
2786               &DirtyReturn;
2787             end;
2788             else if (first.MRN=0 AND first.RxDate=0 AND first.NDC=0) then do;
2789               DirtyReason = "Duplicate MRN, RxDate, NDC";
2790               &DirtyReturn;
2791             end;
2792             else do;
2793               &CleanReturn;
2794             end;
2795           run;
2796           %if &Report = Y %then %do;
2797             proc format;
2798              	value RXSUPf
2799              	  low -  0 = 'Less than zero'
2800              	  0 <-< 28 = '1 to 27'
2801              	  28 - 32  = '28 to 32'
2802              	  32 <-< 58 = '33 to 57'
2803                 58 - 63 = '58 to 63'
2804              	  63 <-< 88 = '64 to 87'
2805              	  88 - 95   = '88 to 95'
2806              	  95 <- high = 'More than 95'
2807              	;
2808               value RXAMTf
2809              	  low - 0 = 'Less than zero'
2810              	  0 <- 20 = '1 to 20'
2811              	  20 <- 40 = '21 to 40'
2812                 40 <- 60 = '41 to 60'
2813              	  60 <- 80 = '61 to 80'
2814              	  80 <- 100 = '81 to 100'
2815              	  100 <- 200 = '101 to 200'
2816              	  200 <- high = 'More than 200'
2817              	;
2818             run;
2819             proc freq data= %if(&Clean=Y) %then &Outlib..Clean; %else Clean;;
2820               title "Frequency Distributions of Obs That Are Clean";
2821               format RxDate Year. RXSUP RXSUPf. RXAMT RXAMTf.;
2822               table RxDate RXSUP RXAMT /missing;
2823             run;
2824             proc freq data= %if(&Dirty=Y) %then &Outlib..Dirty noprint;
2825                             %else Dirty noprint;;
2826               table DirtyReason / out=DirtyReport;
2827             run;
2828             proc contents data=vdwrx.&_RxData. out=RxContents noprint; run;
2829             data WrongLength (keep=vname YourLength SpecLength);
2830               set RxContents;
2831               length vname $32. YourLength 8 SpecLength 8;
2832               vname = upcase(compress(name));
55                                                         The SAS System                               17:43 Friday, April 16, 2010

2833               if vname='MRN' then do;
2834                 call symput('TotalRecords', compress(nobs));
2835                 return;
2836               end;
2837               else if vname="RXDATE" AND length^=4 then do;
2838                 YourLength=length;
2839                 SpecLength=4;
2840                 output;
2841               end;
2842               else if vname="NDC" AND length^=11 then do;
2843                 YourLength=length;
2844                 SpecLength=11;
2845                 output;
2846               end;
2847               else if vname="RXSUP" AND length^=4 then do;
2848                 YourLength=length;
2849                 SpecLength=4;
2850                 output;
2851               end;
2852               else if vname="RXAMT" AND length^=4 then do;
2853                 YourLength=length;
2854                 SpecLength=4;
2855                 output;
2856               end;
2857               else return;
2858             run;
2859             *This should not error nor print if WrongLength is empty;
2860             proc print data=WrongLength;
2861               title "Table of Variables Having the Wrong Length";
2862             run;
2863             title "Frequency of Observations Not up to Specs by Reason";
2864             proc sql;
2865               select DirtyReason
2866                    , COUNT as Frequency
2867                    , COUNT/&TotalRecords. *100 as PercentOfAllRx
2868                    , Percent as PercentOfDirtyRx
2869               from DirtyReport
2870               ;
2871             quit;
2872           %end;
2873         %end;
2874       %mend CleanRx;
2875       
2876       %macro GetVitalSignsForPeople (
2877                     People  /* The name of a dataset containing the people whose
2878                                  vitals you want*/
2879                   , StartDt /* The date on which you want to start collecting vitals*/
2880                   , EndDt   /* The date on which you want to stop collecting vitals */
2881                   , Outset  /* The name of the output dataset containing the vitals */
2882                   ) ;
2883          *Author: Tyler Ross, ross.t@ghc.org , 206-287-2927;
2884          libname __vitals "&_VitalLib" access = readonly ;
2885       
56                                                         The SAS System                               17:43 Friday, April 16, 2010

2886          /*Catch and Throw*/
2887          %if &People = &Outset %then %do ;
2888           %put PROBLEM: The People dataset must be different from the OutSet dataset.;
2889           %put PROBLEM: Both parameters are set to "&People". ;
2890           %put PROBLEM: Doing nothing. ;
2891          %end ;
2892          %else %if %sysfunc(abs("&StartDt"d > "&EndDt"d))=1 %then %do ;
2893            %put PROBLEM: The start date you entered occurrs after the end date ;
2894            %put PROBLEM: Start date is "&StartDt." and end date is "&EndDt." ;
2895            %put PROBLEM: Doing nothing. ;
2896          %end ;
2897          %else %if %sysfunc(exist(&People))=0 %then %do;
2898            %put PROBLEM: The People dataset (&People.) does not exist. ;
2899            %put PROBLEM: Doing nothing. ;
2900          %end;
2901          %else %do;
2902          /*Get Vitals*/
2903            proc sql;
2904              create table &OutSet. as
2905                select v.*
2906                from &People as p
2907                  INNER JOIN
2908                     __vitals.&_VitalData as v
2909                on p.mrn = v.mrn
2910                where v.Measure_Date BETWEEN "&StartDt"d AND "&EndDt"d
2911              ;
2912            quit;
2913          %end;
2914       %mend GetVitalSignsForPeople;
2915       
2916       /********************************************************************
2917       * TESTING GetVitalSignsForPeople;
2918       *
2919       * *GRAB TEST PEOPLE;
2920       * proc sql;
2921       *   create table Afew as select distinct mrn from vdw.&_VitalData
2922       *     where Measure_Date between '01May2005'd AND '15May2005'd;
2923       * quit;
2924       * *Problem 1;
2925       * %*GetVitalSignsForPeople(afew,   05May2005, 10May2005, afew);
2926       * *Problem 2;
2927       * %*GetVitalSignsForPeople(afew,   05May2005, 01Jan1999, myout);
2928       * *Problem 3;
2929       * %*GetVitalSignsForPeople(nodata, 05May2005, 10May2005, myout);
2930       * *No problems;
2931       * %*GetVitalSignsForPeople(afew,   05May2005, 10May2005, myout);
2932       *
2933       **********************************************************************/
2934       
2935       
2936       %macro Diabetes_Charlson(outfile, startdate, enddate, EncType = A);
2937       /***************************************************************************
2938       ****************************************************************************
57                                                         The SAS System                               17:43 Friday, April 16, 2010

2939       * Programmer:
2940       *   Tyler Ross
2941       *   Center For Health Studies
2942       *   (206) 287-2927
2943       *   ross.t@ghc.org
2944       *
2945       * History:  Created September 15, 2006
2946       *
2947       * Purpose:
2948       *   For the diabetes dx as defined by Charlson, this macro creates
2949       *    - A dataset called Diabetes_Charlson with the dx and descriptions
2950       *    - A format called Diabetes_Charlson with the dx
2951       *    - A dataset called &outfile with all people having diabetes
2952       *
2953       * Parameters:
2954       *   Outfile = the file that will contain the list of MRN of those with diabetes
2955       *   StartDate = Date from which you want to start looking for diabetes dx
2956       *   EndDate   = Date from which you want to stop looking for diabetes dx
2957       *   EncType   = Value of A will search All encounters (default),
2958       *               Value of I will search only Inpatient encounters
2959       *               Value of B will search Both IP and OP for dx (but not others)
2960       *
2961       * Dependencies:
2962       *   The Dx file (with the EncType variable as the char(2) version if you use
2963       *                EncType = I or B options)
2964       *   A call to input standard vars before running the macro
2965       *
2966       ***************************************************************************
2967       **************************************************************************/
2968       
2969       *Catch and Throw;
2970       %let EncType = %upcase(&EncType.);
2971       %if (&EncType.^= A AND &EncType. ^= I AND &EncType. ^= B) %then %do;
2972         %put PROBLEM: The parameter 'Inpatient' must be among 'A', 'I', or 'B';
2973         %put PROBLEM: Doing Nothing;
2974         %goto exit;
2975       %end;
2976       %else %if %sysfunc(abs("&StartDate"d > "&EndDate"d))=1 %then %do;
2977         %put PROBLEM: The Startdate must be on or before the EndDate;
2978         %put PROBLEM: Doing Nothing;
2979         %goto exit;
2980       %end;
2981       
2982       /**************************************
2983       *From the Charlson Macro
2984       ***Diabetess;
2985            "250   "-"250.33",
2986       	   "250.7 "-"250.73" = "DIAB"
2987       ***Diabetes with chronic complications
2988       	   "250.4 "-"250.63" = "DIABC"
2989       **************************************/
2990       
2991       libname util "&_UtilizationLib." access = readonly ;
58                                                         The SAS System                               17:43 Friday, April 16, 2010

2992       
2993       * TODO: Break this out into a separate macro that just defines the format, which we can share with the charlson
2993     ! macro--keep it DRY. ;
2994       proc format;
2995         value $Diabetes_Charlson
2996            "250   "-"250.33",
2997       	   "250.7 "-"250.73",
2998       	   "250.4 "-"250.63"  = "DIABC"
2999         ;
3000       run;
3001       
3002       data Diabetes_Charlson;
3003       *Note - Datalines are not allowed in macros;
3004         length diabetes_dx $6 description $50;
3005       
3006       diabetes_dx="250"   ; description="DIABETES MELLITUS"          ; output;
3007       *Just in case lets throw one in with the decimal;
3008       diabetes_dx="250."  ; description="DIABETES MELLITUS"          ; output;
3009       diabetes_dx="250.22"; description="DM2/NOS W HYPEROSMOL UNC"   ; output;
3010       diabetes_dx="250.50"; description="DM2/NOS W EYE MANIF NSU"    ; output;
3011       diabetes_dx="250.0" ; description="DIABETES MELLITUS UNCOMP"   ; output;
3012       diabetes_dx="250.23"; description="DM1 HYPEROSMOLARITY UNC"    ; output;
3013       diabetes_dx="250.51"; description="DM1 W EYE MANIFEST NSU"     ; output;
3014       diabetes_dx="250.00"; description="DM2/NOS UNCOMP NSU"         ; output;
3015       diabetes_dx="250.29"; description="Unspec: adult-onset vs juvenile type";output;
3016       diabetes_dx="250.52"; description="DM2/NOS W EYE MANIF UNC"    ; output;
3017       diabetes_dx="250.01"; description="DM1 UNCOMP NSU"             ; output;
3018       diabetes_dx="250.3" ; description="DIABETES W COMA NEC"        ; output;
3019       diabetes_dx="250.53"; description="DM1 W EYE MANIFEST UNC"     ; output;
3020       diabetes_dx="250.02"; description="DM2/NOS UNCOMP UNC"         ; output;
3021       diabetes_dx="250.30"; description="DM2/NOS W COMA NEC NSU"     ; output;
3022       diabetes_dx="250.59"; description="Unspec: adult-onset vs juvenile type";output;
3023       diabetes_dx="250.03"; description="DM1 UNCOMP UNC"             ; output;
3024       diabetes_dx="250.31"; description="DM1 W COMA NEC NSU"         ; output;
3025       diabetes_dx="250.6" ; description="DM2 NEUROLOGIC MANIFEST"    ; output;
3026       diabetes_dx="250.09"; description="Unspec: adult-onset vs juvenile type";output;
3027       diabetes_dx="503.2" ; description="DM2/NOS W COMA NEC UNC"     ; output;
3028       diabetes_dx="250.60"; description="DM2/NOS W NEUR MANIF NSU"   ; output;
3029       diabetes_dx="250.1" ; description="DIABETES W KETOACIDOSIS"    ; output;
3030       diabetes_dx="250.33"; description="DM1 W COMA NEC UNC"         ; output;
3031       diabetes_dx="250.61"; description="DM1 W NEURO MANIFEST NSU"   ; output;
3032       diabetes_dx="250.10"; description="DM2/NOS W KETOACID NSU"     ; output;
3033       diabetes_dx="250.4" ; description="DM W RENAL MANIFESTATION"   ; output;
3034       diabetes_dx="250.62"; description="DM2/NOS W NEUR MANIF UNC"   ; output;
3035       diabetes_dx="250.11"; description="DM1 W KETOACIDOSIS NSU"     ; output;
3036       diabetes_dx="250.40"; description="DM2/NOS W REN MANIF NSU"    ; output;
3037       diabetes_dx="250.63"; description="DM1 W NEURO MANIFEST UNC"   ; output;
3038       diabetes_dx="250.12"; description="DM2/NOS W KETOACID UNC"     ; output;
3039       diabetes_dx="250.41"; description="DM1 W RENAL MANIFEST NSU"   ; output;
3040       diabetes_dx="250.7" ; description="DM W CIRC DISORDER"         ; output;
3041       diabetes_dx="250.13"; description="DM1 W KETOACIDOSIS UNC"     ; output;
3042       diabetes_dx="250.42"; description="DM2/NOS W REN MANIF UNC"    ; output;
3043       diabetes_dx="250.70"; description="DM2/NOS W CIRC DIS NSU"     ; output;
59                                                         The SAS System                               17:43 Friday, April 16, 2010

3044       diabetes_dx="250.19"; description="Unspec: adult-onset vs juvenile type";output;
3045       diabetes_dx="250.43"; description="DM1 W RENAL MANIFEST UNC"   ; output;
3046       diabetes_dx="250.71"; description="DM1 W CIRC DISORD NSU"      ; output;
3047       diabetes_dx="250.2" ; description="DM W HYPEROSMOLARITY"       ; output;
3048       diabetes_dx="250.49"; description="Unspec: adult-onset vs juvenile type";output;
3049       diabetes_dx="250.72"; description="DM2/NOS W CIRC DIS UNC"     ; output;
3050       diabetes_dx="250.20"; description="DM2/NOS W HYPEROSMOL NSU"   ; output;
3051       diabetes_dx="250.5" ; description="DM W OPHTHALMIC MANIFEST"   ; output;
3052       diabetes_dx="250.73"; description="DM1 W CIRC DISORD UNC"      ; output;
3053       diabetes_dx="250.21"; description="DM1 HYPEROSMOLARITY NSU";   ; output;
3054       run;
3055       
3056       proc sql noprint;
3057         create table &outfile as
3058           select distinct mrn
3059           from util.&_DxData
3060           where dx in(select diabetes_dx from diabetes_charlson)
3061             AND adate between "&startdate"d AND "&EndDate"d
3062       %if       %upcase(&EncType.) = I %then AND EncType = "IP";
3063       %else %if %upcase(&EncType.) = B %then AND EncType in("AV", "IP");
3064         ;
3065       quit;
3066       
3067       %exit: %mend Diabetes_Charlson;
3068       
3069       /*TEST SECTION;
3070       *Problem 1;
3071       %Diabetes_Charlson(outfile=MyTest, startdate=01May2004, enddate=15May2004
3072                        , EncType = Z);
3073       *Problem 2;
3074       %Diabetes_Charlson(outfile=MyTest, startdate=15May2004, enddate=01Mar2002
3075                        , EncType = A);
3076       *Success 1;
3077       %Diabetes_Charlson(outfile=MyTest, startdate=01May2004, enddate=15May2004
3078                        , EncType = A);
3079       *Success 2;
3080       %Diabetes_Charlson(outfile=MyTest, startdate=01May2004, enddate=15May2004
3081                        , EncType = I);
3082       *Success 3;
3083       %Diabetes_Charlson(outfile=MyTest, startdate=01May2004, enddate=15May2004
3084                        , EncType = B);
3085       */
3086       
3087       
3088       
3089       %macro GetDateRange(path, filename, print=1);
3090       /***************************************************************************
3091       ****************************************************************************
3092       * Programmer:
3093       *   Tyler Ross
3094       *   Center For Health Studies
3095       *   (206) 287-2927
3096       *   ross.t@ghc.org
60                                                         The SAS System                               17:43 Friday, April 16, 2010

3097       *
3098       * History:
3099       *   Created Sept 18, 2006
3100       *
3101       * Purpose:
3102       *   For every variable in path.filename that has a date format, this macro
3103       *     creates two global macro variables in date9 format with the names
3104       *     TheDateVar_Min and TheDateVar_Max
3105       *   You may optionally print the results to the lst file
3106       *
3107       * Parameters:
3108       *   Path = The path name to the data file (which will get called as a libname)
3109       *   Filename = The name of the data set
3110       *   Print = Set to 0 will supress the date ranges printed to screen
3111       *           Set to 1 (default) will show all date vars min and max values
3112       *
3113       * Examples:
3114       *   %GetDateRange(&_TumorLib., &_TumorData.);
3115       *   ...will create the global variables
3116       *     DOD_Max, DOD_Min, BDate_Max, BDate_Min, DxDate_Max, DxDate_Min,
3117       *     DT_Surg_Max, DT_Surg_Min and so forth where...
3118       *   &DOD_MAX = 09Sep2006
3119       *   &DOD_Min = 01Feb1982
3120       *   and so forth
3121       *
3122       ***************************************************************************
3123       **************************************************************************/
3124         libname __PATH "&path.";
3125       
3126         %if %sysfunc(exist(__Path.&filename.)) = 0 %then %do;
3127           %put PROBLEM: The file &filename. does not exist in the path you specified;
3128           %put PROBLEM: Path = &path.;
3129           %put PROBLEM: DOING NOTHING;
3130           %goto exit;
3131         %end;
3132         %else %if (&print. ^=0 AND &print. ^=1) %then %do;
3133           %put PROBLEM: The print parameter must be equal to zero (0) or one (1);
3134           %put PROBLEM: DOING NOTHING;
3135           %goto exit;
3136         %end;
3137       
3138         *Go through the select twice -once for the globals that will be made;
3139         *  Once for the locals for the summary proc;
3140         proc sql noprint;
3141             select compress(name) || "_Max " || compress(name) || "_Min"
3142                    into: ForGlobals separated by " "
3143             from dictionary.columns
3144             where upcase(compress(type))    = "NUM"
3145               AND upcase(compress(libname)) = "__PATH"
3146               AND upcase(compress(MemName)) = upcase("&filename")
3147               AND (
3148                    index(upcase(format), "DATE") > 0
3149                   OR
61                                                         The SAS System                               17:43 Friday, April 16, 2010

3150                    index(upcase(format), "YY") > 0
3151                   OR
3152                    index(upcase(format), "JULIAN") > 0
3153                   )
3154           ;
3155           select name into: DateVars_&filename. separated by " "
3156             from dictionary.columns
3157             where upcase(compress(type))    = "NUM"
3158               AND upcase(compress(libname)) = "__PATH"
3159               AND upcase(compress(MemName)) = upcase("&filename")
3160               AND (
3161                    index(upcase(format), "DATE") > 0
3162                   OR
3163                    index(upcase(format), "YY") > 0
3164                   OR
3165                    index(upcase(format), "JULIAN") > 0
3166                   )
3167           ;
3168         quit;
3169       
3170         *Verify that the macro variable exists (that there is at least one date var);
3171         %if %symexist(DateVars_&filename.) %then %do;
3172       
3173           %put The date variables in &filename. are &&DateVars_&filename;
3174           *Get the min and max of the date vars;
3175           proc summary data= __Path.&filename. noprint min max;
3176             var &&DateVars_&filename;
3177             output out=Ranges;
3178           run;
3179           *Make MAX come before MIN;
3180           proc sort data=Ranges; by _STAT_; run;
3181       
3182           *Allow user to see the results in the .lst file;
3183           %if &print. = 1 %then %do;
3184            proc print data=Ranges;
3185            title "The minimum and maximum values of the date variables in &filename.";
3186              where upcase(compress(_STAT_)) in("MIN", "MAX");
3187            run;
3188           %end;
3189       
3190           *Declare the variables as global - call symput will default to local o.w.;
3191           %global &ForGlobals;
3192           *Create local variables holding the min and max values;
3193           data _NULL_;
3194             set Ranges (where=(upcase(compress(_STAT_)) in("MIN", "MAX")));
3195       
3196             array datevars {*} _NUMERIC_ ;
3197             if _n_ = 1 then do;
3198               do i=1 to dim(datevars);
3199                 if vname(datevars{i}) NOT IN("_TYPE_", "_FREQ_", "_STAT_") then
3200                   call symput(vname(datevars{i}) || "_Max", put(datevars{i}, date9.));
3201               end;
3202             end;
62                                                         The SAS System                               17:43 Friday, April 16, 2010

3203             else do;
3204               do i=1 to dim(datevars);
3205                 if vname(datevars{i}) NOT IN("_TYPE_", "_FREQ_", "_STAT_") then
3206                   call symput(vname(datevars{i}) || "_Min", put(datevars{i}, date9.));
3207               end;
3208             end;
3209           run;
3210       
3211           *Clean up;
3212           proc sql;
3213             drop table Ranges;
3214           quit;
3215         %end;
3216         %else %do;
3217           %put PROBLEM: Sorry, but no date variables were found in &filename;
3218           %put PROBLEM: Verify that &filename. has at least one numeric variable;
3219           %put PROBLEM: formatted as a date variable;
3220           %goto exit;
3221         %end;
3222       
3223       %exit: %mend GetDateRange;
3224       
3225       *TEST SECTION;
3226       /*******************
3227       * Raise exceptions *
3228       *******************/
3229       *Print var out of range;
3230       %*GetDateRange(&_RxLib. , &_RxData., print=2);
3231       *Data that doesnt exist;
3232       %*GetDateRange(&_RxLib. , NotReal);
3233       *A file with no date variables;
3234       %*GetDateRange(&_RxLib. , &_EverNDCData);
3235       
3236       *NOW FOR SUCCESSFUL RUNS;
3237       %*GetDateRange(&_UtilizationLib. , &_DXDATA.   , print=0);
3238       %*GetDateRange(&_TumorLib.       , &_TUMORDATA., print=1);
3239       %*GetDateRange(&_RxLib.          , &_RxData.   , print=1);
3240       %*GetDateRange(&_VitalLib.       , &_VitalData          );
3241       
3242       %*put _user_;
3243       
3244       
3245       %macro Hypertension_BP(outfile, startdate, enddate,
3246                              Diastolic_Min = 90, Systolic_Min = 140,
3247                              Strict_Equality = 0, Either = 1);
3248       
3249       /***************************************************************************
3250       ****************************************************************************
3251       * Programmer:
3252       *   Tyler Ross
3253       *   Center For Health Studies
3254       *   (206) 287-2927
3255       *   ross.t@ghc.org
63                                                         The SAS System                               17:43 Friday, April 16, 2010

3256       *
3257       * History: Created September 27, 2006
3258       
3259       * Purpose:
3260       *   Pulls all people with a systolic and-or diastolic BP reading above
3261       *     specified threasholds over specified dates along with their highest
3262       *     systolic and diastolic readings in that period. Can be used to defined
3263       *     hypertension.
3264       *
3265       * Parameters:
3266       *   Outfile = The name of the file that will be output
3267       *   StartDate = The date from which you want to start looking for BP
3268       *   EndDate   = The date to which you want to end looking for BP
3269       *   Diastolic_Min = The minimum diastolic value that will be allowed in output
3270       *   Systolic_Min  = The minimum systolic  value that will be allowed in output
3271       *   Strict_Equality = 0 allows BP readings of min values and above
3272       *                     1 only allows BP readings above the min values
3273       *   Either = 0 requires a systolic AND a diastolic reading above the min
3274       *            1 allows either a systolic OR a diastolic reading above the min
3275       *
3276       * Notes:
3277       *   Systolic and diastolic readings above mins are not required to be on
3278       *   the same day when Either = 0 is specified.
3279       *
3280       ***************************************************************************
3281       **************************************************************************/
3282       
3283       %if %sysfunc(abs("&StartDate"d > "&EndDate"d))=1 %then %do;
3284         %put PROBLEM: The StartDate must be on or before the EndDate;
3285         %put StartDate is &StartDate., EndDate is &EndDate.;
3286         %put PROBLEM: Doing Nothing;
3287         %goto exit;
3288       %end;
3289       %if (&Diastolic_Min < 0 OR &Systolic_Min < 0) %then %do;
3290         %put PROBLEM: The min values for BP must be non-negative;
3291         %put Diastolic_Min = &Diastolic_Min. , Systolic_Min = &Systolic_Min.;
3292         %put PROBLEM: Doing Nothing;
3293         %goto exit;
3294       %end;
3295       %if (&Strict_Equality. ^= 0 AND &Strict_Equality. ^= 1) %then %do;
3296         %put PROBLEM: The Strict_Equality variable must be 0 or 1;
3297         %put Strict_Equality = &Strict_Equality;
3298         %put PROBLEM: Doing Nothing;
3299         %goto exit;
3300       %end;
3301       %if (&Either. ^= 0 AND &Either. ^= 1) %then %do;
3302         %put PROBLEM: The Either variable must be 0 or 1;
3303         %put Either = &Either;
3304         %put PROBLEM: Doing Nothing;
3305         %goto exit;
3306       %end;
3307       
3308       *Create conditional;
64                                                         The SAS System                               17:43 Friday, April 16, 2010

3309       %if (&Strict_Equality. = 0 AND &Either. = 1) %then %do;
3310         %let Conditional= max(Diastolic) >= &Diastolic_Min.
3311                        OR max(Systolic)  >= &Systolic_Min.;
3312       %end;
3313       %else %if (&Strict_Equality. = 1 AND &Either. = 1) %then %do;
3314         %let Conditional= max(Diastolic) > &Diastolic_Min.
3315                        OR max(Systolic)  > &Systolic_Min.;
3316       %end;
3317       %else %if (&Strict_Equality. = 0 AND &Either. = 0) %then %do;
3318         %let Conditional= max(Diastolic) >= &Diastolic_Min.
3319                       AND max(Systolic)  >= &Systolic_Min.;
3320       %end;
3321       %else %if (&Strict_Equality. = 1 AND &Either. = 0) %then %do;
3322         %let Conditional= max(Diastolic) > &Diastolic_Min.
3323                       AND max(Systolic)  > &Systolic_Min.;
3324       %end;
3325       
3326       libname vs "&_VitalLib" access=readonly;
3327       
3328       proc sql;
3329        create table &outfile. as
3330          select mrn
3331               , max(Diastolic) as Max_Diastolic
3332        label = "Person's highest diastolic reading between &StartDate. and &EndDate."
3333               , max(Systolic)  as Max_Systolic
3334        label = "Person's highest systolic reading between &StartDate. and &EndDate."
3335          from vs.&_VitalData. (where=(Measure_Date between "&StartDate"d
3336                                                        AND "&EndDate"d  ))
3337          group by mrn
3338          having &Conditional.
3339        ;
3340       quit;
3341       
3342       %exit: %mend Hypertension_BP;
3343       
3344       /*TEST SECTION;
3345       proc format;
3346         value sysf
3347           low  -  0    = "Non-positive"
3348           0   <-< 130  = "<130"
3349           130  -< 140  = "130 to 139"
3350           140          = "140"
3351           140 <-< 160  = "140 to 159"
3352           160  -< 180  = "160 to 179"
3353           180  -  high = "180+"
3354         ;
3355         value diaf
3356           low  -  0    = "Non-positive"
3357           0   <-< 80   = "<80"
3358           80   -< 90   = "80 to 89"
3359           90           = "90"
3360           90  <-< 100  = "90 to 99"
3361           100  -< 110  = "100 to 110"
65                                                         The SAS System                               17:43 Friday, April 16, 2010

3362           110  -  high = "110+"
3363         ;
3364       quit;
3365       *Problem 1;
3366       %*Hypertension_BP(outfile= testing, startdate= 04Jan2005, enddate= 15Feb2002);
3367       *Problem 2;
3368       %Hypertension_BP(outfile= testing, startdate= 04Jan2005, enddate= 15Feb2006,
3369                        Diastolic_Min=-5, Systolic_Min=10);
3370       *Problem 3;
3371       %*Hypertension_BP(outfile= testing, startdate= 04Jan2005, enddate= 15Feb2006,
3372                        Strict_Equality=Y);
3373       *Problem 4;
3374       %*Hypertension_BP(outfile= testing, startdate= 04Jan2005, enddate= 15Feb2006,
3375                        Either=2);
3376       
3377       
3378       *Success 1;
3379       %*Hypertension_BP(outfile= testing, startdate= 04Jan2005, enddate= 15Feb2006);
3380       proc freq data=testing;
3381         title "Success 1";
3382         format Max_Diastolic diaf. Max_Systolic sysf.;
3383         table Max_Diastolic*Max_Systolic /missing;
3384       run;
3385       proc sort data=testing NODUPKEY; by mrn; run;
3386       *Success 2;
3387       %*Hypertension_BP(outfile= testing, startdate= 04Jan2005, enddate= 15Feb2006,
3388                        Diastolic_Min=85, Systolic_Min=135);
3389       proc freq data=testing;
3390         title "Success 2";
3391         format Max_Diastolic diaf. Max_Systolic sysf.;
3392         table Max_Diastolic*Max_Systolic /missing;
3393       run;
3394       *Success 3;
3395       %*Hypertension_BP(outfile= testing, startdate= 04Jan2005, enddate= 15Feb2006,
3396                        Strict_Equality=1, Either=1);
3397       proc freq data=testing;
3398         title "Success 3";
3399         format Max_Diastolic diaf. Max_Systolic sysf.;
3400         table Max_Diastolic*Max_Systolic /missing;
3401       run;
3402       *Success 4;
3403       %*Hypertension_BP(outfile= testing, startdate= 04Jan2005, enddate= 15Feb2006,
3404                        Strict_Equality=0, Either=0);
3405       proc freq data=testing;
3406         title "Success 4";
3407         format Max_Diastolic diaf. Max_Systolic sysf.;
3408         table Max_Diastolic*Max_Systolic /missing;
3409       run;
3410       *Success 5;
3411       %*Hypertension_BP(outfile= testing, startdate= 04Jan2005, enddate= 15Feb2006,
3412                        Strict_Equality=1, Either=0);
3413       proc freq data=testing;
3414         title "Success 5";
66                                                         The SAS System                               17:43 Friday, April 16, 2010

3415         format Max_Diastolic diaf. Max_Systolic sysf.;
3416         table Max_Diastolic*Max_Systolic /missing;
3417       run;
3418       *Success 6;
3419       %*Hypertension_BP(outfile= testing, startdate= 04Jan2005, enddate= 15Feb2006,
3420                      Diastolic_Min=90, Systolic_Min=150, Strict_Equality=1, Either=0);
3421       proc freq data=testing;
3422         title "Success 6";
3423         format Max_Diastolic diaf. Max_Systolic sysf.;
3424         table Max_Diastolic*Max_Systolic /missing;
3425       run;
3426       */
3427       
3428       %macro CleanEnroll(OutLib, Clean=N, Dirty=N, Report=Y);
3429       /***************************************************************************
3430       * Parameters:
3431       *   OutLib  = The library name you've already declared where you want output
3432       *             you elect to save (Clean="Y", Dirty="Y") to go.
3433       *   Clean   = "Y" outputs a table (in OutLib) with enroll records deemed clean.
3434       *             Any other value will not output this table.
3435       *   Dirty   = "Y" outputs a table (in Outlib) with enroll records deemed dirty.
3436       *             along with DirtyReason, a text variable explaining why the record
3437       *             is dirty.  Any other value will not output this file.
3438       *   Report  = "Y" will do a freq tabulation on the dirty data by DirtyReason,
3439       *             report misspecified variable lengths, and perform freq tables on
3440       *             the clean data.
3441       *             Any other value will suppress this calculation.
3442       *
3443       * Programmer:
3444       *   Tyler Ross
3445       *   Center For Health Studies
3446       *   (206) 287-2927
3447       *   ross.t@ghc.org
3448       *
3449       * History:
3450       *   Created October 13, 2006
3451       **************************************************************************/
3452       
3453         /*Catch Errors*/
3454         %if &Clean ^= Y AND &Dirty ^= Y AND &Report ^= Y %then %do;
3455           %put ERROR: YOU MUST SPECIFY AT LEAST ONE TABLE TO OUTPUT OR TO PRODUCE;
3456           %put ERROR: A REPORT. SET <<CLEAN>>, <<DIRTY>>, AND/OR <<REPORT>> TO "Y";
3457         %end;
3458         %else %do;
3459           /*This mess is so that we save a little IO time depending on whether
3460             programmer wants the datasets saved.*/
3461           %if &Report ^= Y AND &Clean ^= Y %then %do;
3462             %let DataStatement = &OutLib..Dirty;
3463             %let DirtyReturn   = output &Outlib..dirty;
3464             %let CleanReturn   = ;
3465           %end;
3466           %else %if &Report ^= Y AND &Dirty ^= Y %then %do;
3467             %let DataStatement = &OutLib..Clean (drop=DirtyReason LastEnd);
67                                                         The SAS System                               17:43 Friday, April 16, 2010

3468             %let DirtyReturn = ;
3469             %let CleanReturn = output &Outlib..clean;
3470           %end;
3471           %else %if &Report = Y AND &Clean ^= Y AND &Dirty ^= Y %then %do;
3472             %let DataStatement = Clean (drop=DirtyReason LastEnd) Dirty;
3473             %let DirtyReturn = output dirty;
3474             %let CleanReturn = output clean;
3475           %end;
3476           %else %if &Report = Y AND &Clean = Y AND &Dirty ^= Y %then %do;
3477             %let DataStatement = &Outlib..Clean (drop=DirtyReason LastEnd) Dirty;
3478             %let DirtyReturn = output dirty;
3479             %let CleanReturn = output &Outlib..clean;
3480           %end;
3481           %else %if &Report = Y AND &Clean ^= Y AND &Dirty = Y %then %do;
3482             %let DataStatement = Clean (drop=DirtyReason LastEnd) &Outlib..Dirty;
3483             %let DirtyReturn = output &Outlib..dirty;
3484             %let CleanReturn = output clean;
3485           %end;
3486           %else %do; /*They want both clean and dirty, regardless of report*/
3487         %let DataStatement = &Outlib..Clean (drop=DirtyReason LastEnd) &Outlib..Dirty;
3488             %let DirtyReturn = output &Outlib..dirty;
3489             %let CleanReturn = output &Outlib..clean;
3490           %end;
3491       
3492           /*Clean the data*/
3493           libname __enroll "&_EnrollLib.";
3494           proc sort data=__enroll.&_EnrollData out=ToClean;
3495             by mrn enr_start;
3496           run;
3497       
3498           data &DataStatement;
3499             set ToClean;
3500             by mrn enr_start;
3501             length DirtyReason $40 LastEnd 4 DaysEnrolled 8;
3502       
3503             DaysEnrolled = Enr_End - Enr_Start + 1;
3504       
3505             if MISSING(MRN)=1 then do;
3506               DirtyReason = "Missing MRN";
3507               &DirtyReturn;
3508             end;
3509             else if MISSING(enr_start)=1 then do;
3510               DirtyReason = "Missing ENR_Start";
3511               &DirtyReturn;
3512             end;
3513             else if MISSING(enr_end)=1 then do;
3514               DirtyReason = "Missing ENR_End";
3515               &DirtyReturn;
3516             end;
3517             else if enr_end < enr_start then do;
3518               DirtyReason = "Enr_end is BEFORE enr_start";
3519               &DirtyReturn;
3520             end;
68                                                         The SAS System                               17:43 Friday, April 16, 2010

3521             else if first.MRN = 0 AND LastEND > enr_start then do;
3522               DirtyReason = "Enroll period overlaps with other obs";
3523               &DirtyReturn;
3524             end;
3525             else if INS_MEDICARE NOT IN("Y", "") then do;
3526               DirtyReason = "Invalid value for INS_MEDICARE";
3527               &DirtyReturn;
3528             end;
3529             else if INS_MEDICAID NOT IN("Y", "") then do;
3530               DirtyReason = "Invalid value for INS_MEDICAID";
3531               &DirtyReturn;
3532             end;
3533             else if INS_Commercial NOT IN("Y", "") then do;
3534               DirtyReason = "Invalid value for INS_COMMERCIAL";
3535               &DirtyReturn;
3536             end;
3537             else if INS_PRIVATEPAY NOT IN("Y", "") then do;
3538               DirtyReason = "Invalid value for INS_PRIVATEPAY";
3539               &DirtyReturn;
3540             end;
3541             else if INS_OTHER NOT IN("Y", "") then do;
3542               DirtyReason = "Invalid value for INS_OTHER";
3543               &DirtyReturn;
3544             end;
3545             else if DRUGCOV NOT IN("Y", "N", "") then do;
3546               DirtyReason = "Invalid value for DRUGCOV";
3547               &DirtyReturn;
3548             end;
3549             else do;
3550               &CleanReturn;
3551             end;
3552             LastEnd = enr_end;
3553             retain LastEnd;
3554           run;
3555       
3556           %if &Report = Y %then %do;
3557             proc format;
3558               value DEnrollf
3559                 1           = "1 Day"
3560                 2    - 27   = "2 to 27 days"
3561                 28   - 31   = "28 to 31 days"
3562                 32   - 93   = "32 to 93 days"
3563                 94   - 186  = "94 to 186 days"
3564                 187  - 363  = "187 to 363 days"
3565                 364  - 366  = "364 to 366 days"
3566                 367  - 1096 = "367 to 1096 days (3 years)"
3567                 1096 - high = "More than 1096 days"
3568                 other       = "Other?!"
3569               ;
3570             run;
3571             proc freq data= %if(&Clean=Y) %then &Outlib..Clean; %else Clean;;
3572               title "Frequency Distributions of Obs That Are Clean";
3573               format Enr_Start MMYY. Enr_End MMYY. DaysEnrolled DEnrollf.;
69                                                         The SAS System                               17:43 Friday, April 16, 2010

3574               table Enr_Start Enr_End DaysEnrolled Ins_Medicare Ins_Medicaid
3575                     Ins_Commercial Ins_PrivatePay Ins_Other DRUGCOV;
3576             run;
3577             proc freq data= %if(&Dirty=Y) %then &Outlib..Dirty noprint;
3578                             %else Dirty noprint;;
3579               table DirtyReason / out=DirtyReport;
3580             run;
3581             proc contents data=__enroll.&_EnrollData. out=EnrollContents noprint;
3582             run;
3583       
3584             data WrongLength (keep=vname YourLength SpecLength);
3585               set EnrollContents;
3586               length vname $32. YourLength 8 SpecLength 8;
3587               vname = upcase(compress(name));
3588               if vname='MRN' then do;
3589                 call symput('TotalRecords', compress(nobs));
3590                 return;
3591               end;
3592               else if vname="INS_MEDICARE" AND length^=1 then do;
3593                 YourLength=length;
3594                 SpecLength=1;
3595                 output;
3596               end;
3597               else if vname="INS_MEDICAid" AND length^=1 then do;
3598                 YourLength=length;
3599                 SpecLength=1;
3600                 output;
3601               end;
3602               else if vname="INS_COMMERCIAL" AND length^=1 then do;
3603                 YourLength=length;
3604                 SpecLength=1;
3605                 output;
3606               end;
3607               else if vname="INS_PRIVATEPAY" AND length^=1 then do;
3608                 YourLength=length;
3609                 SpecLength=1;
3610                 output;
3611               end;
3612               else if vname="INS_OTHER" AND length^=1 then do;
3613                 YourLength=length;
3614                 SpecLength=1;
3615                 output;
3616               end;
3617               else if vname="DRUGCOV" AND length^=1 then do;
3618                 YourLength=length;
3619                 SpecLength=1;
3620                 output;
3621               end;
3622               else return;
3623             run;
3624       
3625             *This should not error nor print if WrongLength is empty;
3626             proc print data=WrongLength;
70                                                         The SAS System                               17:43 Friday, April 16, 2010

3627               title "Table of Variables Having the Wrong Length";
3628             run;
3629             title "Frequency of Observations Not up to Specs by Reason";
3630             proc sql;
3631               select DirtyReason
3632                    , COUNT as Frequency
3633                    , COUNT/&TotalRecords. *100 as PercentOfAllEnroll
3634                    , Percent as PercentOfDirtyEnroll
3635                 from DirtyReport
3636               ;
3637             quit;
3638           %end;
3639         %end;
3640       %mend CleanEnroll;
3641       
3642       %macro CleanVitals(OutLib, Clean=N, Dirty=N, Report=Y, Limits=N);
3643       /***************************************************************************
3644       * Parameters:
3645       *   OutLib  = The library name you've already declared where you want output
3646       *             you elect to save (Clean="Y", Dirty="Y") to go.
3647       *   Clean   = "Y" outputs a table (in OutLib) with records deemed clean.
3648       *             Any other value will not output this table.
3649       *   Dirty   = "Y" outputs a table (in Outlib) with records deemed dirty.
3650       *             along with DirtyReason, a text variable explaining why the record
3651       *             is dirty.  Any other value will not output this file.
3652       *   Report  = "Y" will do a freq tabulation on the dirty data by DirtyReason,
3653       *             report misspecified variable lengths, and perform freq tables on
3654       *             the clean data.
3655       *             Any other value will suppress this calculation.
3656       *   Limits  = "Y outputs a table called LIMITS (in Outlib) with only those
3657       *             values in the vitals sign dataset that values compatible with life
3658       *
3659       * Programmer:
3660       *   Tyler Ross
3661       *   Center For Health Studies
3662       *   (206) 287-2927
3663       *   ross.t@ghc.org
3664       *
3665       * History:
3666       *   Created January 8, 2007
3667       **************************************************************************/
3668       
3669         /*Catch Errors*/
3670         %if &Clean ^= Y AND &Dirty ^= Y AND &Report ^= Y %then %do;
3671           %put ERROR: YOU MUST SPECIFY AT LEAST ONE TABLE TO OUTPUT OR TO PRODUCE;
3672           %put ERROR: A REPORT. SET <<CLEAN>>, <<DIRTY>>, AND/OR <<REPORT>> TO "Y";
3673         %end;
3674         %else %do;
3675           /*This mess is so that we save a little IO time depending on whether
3676             programmer wants the datasets saved.*/
3677           %if &Report ^= Y AND &Clean ^= Y %then %do;
3678             %let DataStatement = &OutLib..Dirty;
3679             %let DirtyReturn   = output &Outlib..dirty;
71                                                         The SAS System                               17:43 Friday, April 16, 2010

3680             %let CleanReturn   = output clean;
3681           %end;
3682           %else %if &Report ^= Y AND &Dirty ^= Y %then %do;
3683             %let DataStatement = &OutLib..Clean (drop=DirtyReason);
3684             %let DirtyReturn = ;
3685             %let CleanReturn = output &Outlib..clean;
3686           %end;
3687           %else %if &Report = Y AND &Clean ^= Y AND &Dirty ^= Y %then %do;
3688             %let DataStatement = Clean (drop=DirtyReason) Dirty;
3689             %let DirtyReturn = output dirty;
3690             %let CleanReturn = output clean;
3691           %end;
3692           %else %if &Report = Y AND &Clean = Y AND &Dirty ^= Y %then %do;
3693             %let DataStatement = &Outlib..Clean (drop=DirtyReason) Dirty;
3694             %let DirtyReturn = output dirty;
3695             %let CleanReturn = output &Outlib..clean;
3696           %end;
3697           %else %if &Report = Y AND &Clean ^= Y AND &Dirty = Y %then %do;
3698             %let DataStatement = Clean (drop=DirtyReason ) &Outlib..Dirty;
3699             %let DirtyReturn = output &Outlib..dirty;
3700             %let CleanReturn = output clean;
3701           %end;
3702           %else %do; /*They want both clean and dirty, regardless of report*/
3703         %let DataStatement = &Outlib..Clean (drop=DirtyReason) &Outlib..Dirty;
3704             %let DirtyReturn = output &Outlib..dirty;
3705             %let CleanReturn = output &Outlib..clean;
3706           %end;
3707       
3708           /*Clean the data*/
3709           libname __vitals "&_VitalLib." access=readonly;
3710       
3711           *IMPUTE BMI FROM SCRATCH;
3712           %LET verybig = 10000000000000000;
3713           data NumberOff;
3714             set __vitals.&_VitalData.;
3715             length id 8;
3716             id=_n_;
3717           run;
3718           proc sort data=NumberOff out=Forwards;  by MRN            Measure_Date; run;
3719           proc sort data=NumberOff out=Backwards; by MRN Descending Measure_Date; run;
3720       
3721           data forwardBMI (keep=id CDays_Diff CBMI absdiff);
3722             set forwards (keep=MRN HT WT Measure_Date id Days_Diff BMI);
3723             length
3724               oldht      8
3725           	  CDays_Diff 4
3726           	  olddt      4
3727           	  absdiff    4
3728           	  CBMI       8
3729             ;
3730       
3731             by mrn;
3732       
72                                                         The SAS System                               17:43 Friday, April 16, 2010

3733             *Calculate BMI, take old HT when HT is missing;
3734             if WT = . then do; CBMI = .; CDays_Diff=.; absdiff=&verybig; end;
3735             else do;
3736               if (HT^=.)  then do;
3737                 CBMI = round((WT*0.454)/(HT*0.0254 * HT*0.0254), 0.1);
3738           	    CDays_Diff=0;
3739           	    absdiff=.;
3740                 oldht = HT;
3741                 olddt=Measure_Date;
3742               end;
3743               else if(oldht=.) then do; CBMI=.; CDays_Diff=.; absdiff=&verybig; end;
3744               else do;
3745                 CBMI = round((WT*0.454)/(oldht*0.0254 * oldht*0.0254), 0.1);
3746                 CDays_Diff = (olddt - Measure_Date) ;
3747           	    absdiff = abs(CDays_Diff);
3748               end;
3749             end;
3750       
3751             if last.mrn=1 then do; oldht = .; olddt=.; end;
3752             retain oldht olddt;
3753           run;
3754       
3755           data backwardBMI (keep=id CDays_Diff CBMI absdiff);
3756             set backwards (keep=MRN HT WT Measure_Date id Days_Diff BMI);
3757             length
3758               oldht      8
3759           	  CDays_Diff 4
3760           	  olddt      4
3761           	  absdiff    4
3762           	  CBMI       8
3763             ;
3764       
3765             by mrn;
3766       
3767             *Calculate BMI, take old HT when HT is missing;
3768             if WT = . then do; CBMI = .; CDays_Diff=.; absdiff=&verybig; end;
3769             else do;
3770               if (HT^=.)  then do;
3771                 CBMI = round((WT*0.454)/(HT*0.0254 * HT*0.0254), 0.1);
3772           	    CDays_Diff=0;
3773           	    absdiff=0;
3774                 oldht = HT;
3775                 olddt=Measure_Date;
3776               end;
3777               else if(oldht=.) then do; CBMI=.; CDays_Diff=.; absdiff=&verybig; end;
3778               else do;
3779                 CBMI = round((WT*0.454)/(oldht*0.0254 * oldht*0.0254), 0.1);
3780           	  /*VERY TRICKY - This line stays the same despite the backward run*/
3781                 CDays_Diff = (olddt - Measure_Date);
3782           	    absdiff = abs(CDays_Diff);
3783               end;
3784             end;
3785       
73                                                         The SAS System                               17:43 Friday, April 16, 2010

3786             if last.mrn=1 then do; oldht = .; olddt=.; end;
3787             retain oldht olddt;
3788           run;
3789           /*Keep the version with the smaller date difference*/
3790           proc append base=backwardBMI  data=forwardBMI; run;
3791           proc sort   data=backwardBMI; by id absdiff; run;
3792           proc sort   data=backwardBMI NODUPKEY; by id; run;
3793       
3794           *APPEND CBMI to dataset;
3795           data &DataStatement;
3796             merge NumberOff
3797                   BackwardBMI;
3798             by id;
3799       
3800             length DirtyReason $40 ;
3801       
3802             if MISSING(MRN)=1 then do;
3803               DirtyReason = "Missing MRN";
3804               &DirtyReturn;
3805             end;
3806             else if MISSING(Measure_Date)=1 then do;
3807               DirtyReason = "Missing Measure_Date";
3808               &DirtyReturn;
3809             end;
3810             else if HT < 0 AND MISSING(HT)=0 then do;
3811               DirtyReason = "HT is less than zero";
3812               &DirtyReturn;
3813             end;
3814             else if WT < 0 AND MISSING(WT)=0 then do;
3815               DirtyReason = "WT is less than zero";
3816               &DirtyReturn;
3817             end;
3818             else if Diastolic < 0 AND MISSING(Diastolic)=0 then do;
3819               DirtyReason = "Diastolic is less than zero";
3820               &DirtyReturn;
3821             end;
3822             else if Systolic < 0 AND MISSING(Systolic)=0 then do;
3823               DirtyReason = "Systolic is less than zero";
3824               &DirtyReturn;
3825             end;
3826             else if BMI < 0 AND MISSING(BMI)=0 then do;
3827               DirtyReason = "BMI is less than zero";
3828               &DirtyReturn;
3829             end;
3830             else if POSITION NOT IN("1", "2", "3", "") then do;
3831               DirtyReason = "Invalid value for Position";
3832               &DirtyReturn;
3833             end;
3834             else if round(BMI, 0.1) ^= round(CBMI, 0.1) then do;
3835               DirtyReason = "BMI value is imputed incorrectly";
3836               &DirtyReturn;
3837             end;
3838             else if Days_Diff ^= CDays_Diff then do;
74                                                         The SAS System                               17:43 Friday, April 16, 2010

3839               if (Days_Diff = CDays_Diff *-1 AND Days_Diff ^= 0)
3840                 then DirtyReason = "Days_Diff is of the opposite sign";
3841                 else DirtyReason = "Days_Diff is not correct";
3842               &DirtyReturn;
3843             end;
3844             else do;
3845               &CleanReturn;
3846             end;
3847           run;
3848       
3849           *MANUFACTURE REPORT;
3850           %if &Report = Y %then %do;
3851             proc format;
3852               value HTf
3853                 0          = 'Exactly zero'
3854                 0  <-  12  = '0 to 1 foot'
3855                 12 <-  24  = '1 to 2 feet'
3856                 24 <-  36  = '2 to 3 feet'
3857                 36 <-  48  = '3 to 4 feet'
3858                 48 <-  60  = '4 to 5 feet'
3859                 60 <-  72  = '5 to 6 feet'
3860                 72 <-  84  = '6 to 7 feet'
3861                 84 <-  96  = '7 to 8 feet'
3862                 96 <-  108 = '8 to 9 feet'
3863                 108 <- 120 = '9 to 10 feet'
3864                 120 <- high = 'Over 10 feet'
3865                 .          = 'Missing'
3866                 other      = 'Less than zero?!'
3867               ;
3868               value WTf
3869                 0          = 'Zero exactly'
3870                 0   <-  40 = '0 to 40 pounds'
3871                 40  <-  80 = '40 to 80 pounds'
3872                 80  <- 120 = '80 to 120 pounds'
3873                 120 <- 160 = '120 to 160 pounds'
3874                 160 <- 200 = '160 to 200 pounds'
3875                 200 <- 240 = '200 to 240 pounds'
3876                 240 <- 280 = '240 to 280 pounds'
3877                 280 <- 320 = '280 to 320 pounds'
3878                 320 <- 400 = '320 to 400 pounds'
3879                 400 <- 500 = '400 to 500 pounds'
3880                 500 <- 600 = '500 to 600 pounds'
3881                 600 - high = 'More than 600 pounds'
3882                 .          = 'Missing'
3883                 other      = 'Less than zero?!'
3884               ;
3885               value datediff
3886                -10000 -< -5000  = '-10000 to -5000'
3887                 -5000 -< -2500  = '-5000 to -2500'
3888                 -2500 -< -365   = '-2500 to -365'
3889                 -365  -< -180   = '-365 to -180'
3890                 -180  -< -30    = '-180 to -30'
3891                 -30   -< 0      = '-30 to 0'
75                                                         The SAS System                               17:43 Friday, April 16, 2010

3892                 0               = '0 exactly'
3893                 0     <-< 30    = '0 to 30'
3894                 30     -< 180   = '30 to 180'
3895                 180    -< 365   = '180 to 365'
3896                 365    -< 2500  = '365 to 2500'
3897                 2500   -< 5000  = '2500 to 5000'
3898                 5000   -< 10000 = '5000 to 10000'
3899                 .               = 'Missing'
3900                 other           = 'Other'
3901               ;
3902               value systolicf
3903                 0            = "Exactly zero"
3904                 0   <-< 110  = "<110"
3905                 110  -< 120  = "110 to 119"
3906                 120  -< 130  = "120 to 129"
3907                 130  -< 140  = "130 to 139"
3908                 140          = "140"
3909                 140 <-< 150  = "140 to 149"
3910                 150  -< 160  = "150 to 159"
3911                 160  -< 170  = "160 to 169"
3912                 170  -< 180  = "170 to 179"
3913                 180  -  high = "180+"
3914                 .            = "Missing"
3915                 other        = "Less than zero?!"
3916               ;
3917               value diastolicf
3918                 0            = "Exactly zero"
3919                 0   <-< 60   = "<60"
3920                 60   -< 70   = "60 to 69"
3921                 70   -< 80   = "70 to 79"
3922                 80   -< 90   = "80 to 89"
3923                 90           = "90"
3924                 90  <-< 100  = "90 to 99"
3925                 100  -< 110  = "100 to 109"
3926                 110  -< 120  = "110 to 119"
3927                 120  -< 130  = "120 to 129"
3928                 130  -  high = "130+"
3929                 .            = "Missing"
3930                 other        = "Less than zero?!"
3931               ;
3932               value BMIf
3933         	      0             = 'Zero'
3934       	        0    <-< 18.5 = 'Adult Underweight'
3935       	        18.5  -< 25   = 'Adult Normal'
3936                 25    -< 30   = 'Adult Overweight'
3937       	        30    - 50    = 'Adult Obese to 50'
3938       	        50   <- high  = 'Greater than 50'
3939       	        .             = 'Missing'
3940       	        other         = "Other?!"
3941               ;
3942               value $ positionf
3943                 "1" = "Sitting"
3944                 "2" = "Standing"
76                                                         The SAS System                               17:43 Friday, April 16, 2010

3945                 "3" = "Supine"
3946                 " "  = "Unkown"
3947                 other = "Unexpected Value!?"
3948               ;
3949             run;
3950             proc freq data= %if(&Clean=Y) %then &Outlib..Clean; %else Clean;;
3951               title "Frequency Distributions of Obs That Are Clean";
3952               format HT HTf. WT WTf. Days_Diff datediff. Measure_Date year. BMI BMIf.
3953                      systolic systolicf. diastolic diastolicf. position $positionf.;
3954               table HT WT BMI Days_Diff Measure_Date
3955                     Systolic Diastolic position/missing;
3956             run;
3957             proc freq data= %if(&Dirty=Y) %then &Outlib..Dirty noprint;
3958                             %else Dirty noprint;;
3959               table DirtyReason / out=DirtyReport;
3960             run;
3961             proc contents data=__vitals.&_VitalData. out=VitalContents noprint;
3962             run;
3963       
3964             data WrongLength (keep=vname YourLength SpecLength);
3965               set VitalContents;
3966               length vname $32. YourLength 8 SpecLength 8;
3967               vname = upcase(compress(name));
3968               if vname='MRN' then do;
3969                 call symput('TotalRecords', compress(nobs));
3970                 return;
3971               end;
3972               else if vname="Measure_Date" AND length^=4 then do;
3973                 YourLength=length;
3974                 SpecLength=4;
3975                 output;
3976               end;
3977               else if vname="HT" AND length^=8 then do;
3978                 YourLength=length;
3979                 SpecLength=8;
3980                 output;
3981               end;
3982               else if vname="WT" AND length^=8 then do;
3983                 YourLength=length;
3984                 SpecLength=8;
3985                 output;
3986               end;
3987               else if vname="BMI" AND length^=8 then do;
3988                 YourLength=length;
3989                 SpecLength=8;
3990                 output;
3991               end;
3992               else if vname="DAYS_DIFF" AND length^=4 then do;
3993                 YourLength=length;
3994                 SpecLength=4;
3995                 output;
3996               end;
3997               else if vname="DIASTOLIC" AND length^=4 then do;
77                                                         The SAS System                               17:43 Friday, April 16, 2010

3998                 YourLength=length;
3999                 SpecLength=4;
4000                 output;
4001               end;
4002               else if vname="SYSTOLIC" AND length^=4 then do;
4003                 YourLength=length;
4004                 SpecLength=4;
4005                 output;
4006               end;
4007               else if vname="POSITION" AND length^=1 then do;
4008                 YourLength=length;
4009                 SpecLength=1;
4010                 output;
4011               end;
4012               else return;
4013             run;
4014       
4015             *This should not error nor print if WrongLength is empty;
4016             proc print data=WrongLength;
4017               title "Table of Variables Having the Wrong Length";
4018             run;
4019             title "Frequency of Observations Not up to Specs by Reason";
4020             proc sql;
4021               select DirtyReason
4022                    , COUNT as Frequency
4023                    , COUNT/&TotalRecords. * 100 as PercentOfAllVitalData
4024                    , Percent as PercentOfDirtyVitalData
4025                 from DirtyReport
4026               ;
4027             quit;
4028           %end;
4029         %end;
4030         %if &Limits=Y %then %do;
4031           libname demog "&_DemographicLib." access=readonly;
4032           %if &Clean=Y %then %let cleaner=&Outlib..clean;
4033             %else %let cleaner=clean;
4034           proc sql;
4035             create table &Outlib..LIMITS (drop=_age) as
4036               select a.*
4037                    , %CalcAge(b.Birth_Date, a.Measure_Date) as _age
4038               from &cleaner. as a
4039                 INNER JOIN demog.&_DemographicData as b
4040                 on a.mrn=b.mrn
4041               where
4042                (    (calculated _age = 0               AND a.HT between 3 and 41)
4043                  OR (calculated _age between 1  and 5  AND a.HT between 12 and 60)
4044                  OR (calculated _age between 6  and 12 AND a.HT between 20 and 84)
4045                  OR (calculated _age between 13 and 17 AND a.HT between 30 and 108)
4046                  OR (calculated _age >= 18             AND a.HT between 36 and 108)
4047                  OR MISSING(a.HT)=1
4048                )
4049                AND
4050                (    (calculated _age = 0               AND a.WT between 0 and  80)
78                                                         The SAS System                               17:43 Friday, April 16, 2010

4051                  OR (calculated _age between 1  and 5  AND a.WT between 9 and 200)
4052                  OR (calculated _age between 6  and 12 AND a.WT between 20 and 350)
4053                  OR (calculated _age between 13 and 17 AND a.WT between 25 and 650)
4054                  OR (calculated _age >= 18             AND a.WT between 50 and 1000)
4055                  OR MISSING(a.WT)=1
4056                )
4057                AND (a.BMI between 8 and 200        OR MISSING(a.BMI)=1)
4058                AND (a.Systolic between 50 and 300  OR MISSING(a.Systolic)=1)
4059                AND (a.Diastolic between 20 and 160 OR MISSING(a.Diastolic)=1)
4060             ;
4061           quit;
4062         %end;
4063       %mend CleanVitals;
4064       
4065       %macro SimpleContinuous3(People      /* A dataset of MRNs whose enrollment we are considering. */
4066                            , StartDt      /* A date literal identifying the start of the period of interest. */
4067                            , EndDt        /* A date literal identifying the end of the period of interest. */
4068                            , DaysTol      /* The # of days gap between otherwise contiguous periods of enrollment that is
4068     ! tolerable. */
4069                            , OutSet       /* Name of the desired output dset */
4070                            , EnrollDset = &_vdw_enroll /* For testing. */
4071                            ) ;
4072       
4073       /*
4074       
4075          A simple macro to evaluate whether a group of people were
4076          continuously enrolled over a period of interest.
4077          Motivated by a desire for a simpler macro than VDWs
4078          PullContinuous().
4079       
4080          Produces a dset detailing the enrollment of the MRNs in &People, including a flag
4081          signifying whether the person was continuously enrolled between &StartDt and &EndDt.
4082       */
4083       
4084          proc sql noprint ;
4085             ** How many days long is the period of interest? ;
4086             create table dual (x char(1)) ;
4087             insert into dual(x) values ('x') ;
4088             select ("&EndDt"d - "&StartDt"d + 1) as TotDays
4089                   , intnx('day', "&StartDt"d, -&DaysTol, 'same') as earliest_start format = date9.
4090                   , intnx('day', "&EndDt"d  ,  &DaysTol, 'same') as latest_end     format = date9.
4091                      into :TotDays, :EarliestStart, :LatestEnd
4092             from  dual ;
4093          quit ;
4094       
4095          %put ;
4096          %put ;
4097          %put SimpleContinuous macro--pulling continuous enrollment information for the MRNs in &People ;
4098          %put between &StartDt and &EndDt (&TotDays days total).;
4099          %put ;
4100          %put ;
4101       
4102       /*
79                                                         The SAS System                               17:43 Friday, April 16, 2010

4103         %put Earliest start = &EarliestStart and Latest End = &LatestEnd  ;
4104         %put Earliest start = &EarliestStart and Latest End = &LatestEnd  ;
4105         %put Earliest start = &EarliestStart and Latest End = &LatestEnd  ;
4106         %put Earliest start = &EarliestStart and Latest End = &LatestEnd  ;
4107         %put Earliest start = &EarliestStart and Latest End = &LatestEnd  ;
4108         %put Earliest start = &EarliestStart and Latest End = &LatestEnd  ;
4109         %put Earliest start = &EarliestStart and Latest End = &LatestEnd  ;
4110         %put Earliest start = &EarliestStart and Latest End = &LatestEnd  ;
4111         %put Earliest start = &EarliestStart and Latest End = &LatestEnd  ;
4112         %put Earliest start = &EarliestStart and Latest End = &LatestEnd  ;
4113       */
4114       
4115       
4116          proc sql ;
4117             ** Uniquify the list of MRNs, just in case ;
4118             create table _ids as
4119             select distinct MRN
4120             from &People ;
4121       
4122             ** Gather start/end dates from enrlseed that could possibly cover the period of interest. ;
4123             create table _periods as
4124             select e.MRN
4125                  , e.enr_start
4126                  , e.enr_end
4127             from &EnrollDset as e INNER JOIN
4128                 _ids as i
4129             on    e.MRN = i.MRN
4130             where "&EarliestStart"d le e.enr_end AND
4131                   "&LatestEnd"d     ge e.enr_start
4132                   ;
4133       
4134          ** Collapse any contiguous periods of enrollment. ;
4135          %CollapsePeriods(Lib       = work      /* Name of the library containing the dset you want collapsed */
4136                         , DSet      = _periods  /* Name of the dset you want collapsed. */
4137                         , RecStart  = enr_start   /* Name of the var that contains the period start dates. */
4138                         , RecEnd    = enr_end     /* Name of the var that contains the period end dates. */
4139                         , PersonID  = MRN
4140                         , DaysTol   = &DaysTol  /* The number of days gap to tolerate in evaluating whether one period is
4140     ! contiguous w/another. */
4141                         ) ;
4142       
4143         **  Now we worry about pre-POI and post-POI gaps. ;
4144         proc sort data = _periods ;
4145           by mrn enr_start ;
4146         run ;
4147       
4148         data _periods ;
4149           set _periods ;
4150           by mrn enr_start ;
4151           if first.mrn then do ;
4152             ** If enr_start is within &daystol days after &StartDt, we move enr_start to &StartDt (thereby closing the gap). ;
4153             if 1 ge (enr_start - &StartDt) ge &DaysTol then enr_start = &StartDt ;
4154           end ;
80                                                         The SAS System                               17:43 Friday, April 16, 2010

4155           if last.mrn then do ;
4156             ** If enr_end is within &daystol days before &EndDt, we move enr_end to &EndDt ;
4157             if 1 ge (&EndDt - enr_end) ge &DaysTol then enr_end = &EndDt ;
4158           end ;
4159         run ;
4160       
4161          ** Calculate # of days between start & end date. ;
4162          proc sql ;
4163             create table _period_days as
4164             select MRN
4165                   , (min("&EndDt"d, enr_end) - max("&StartDt"d, enr_start) + 1) as Days
4166             from _periods
4167             where CALCULATED days > 0
4168             ;
4169       
4170             create table &OutSet(label = "Enrollment information for the MRNs in &People") as
4171             select mrn
4172                   , sum(days) as CoveredDays label = "Number of enrolled days between &StartDt and &EndDt"
4173                   , (sum(days) = &TotDays) as ContinuouslyEnrolled label = "0/1 flag answering was this person continuously
4173     ! enrolled from &StartDt to &EndDt. (disregarding gaps up to &DaysTol days)?"
4174             from _period_days
4175             group by mrn
4176             ;
4177             insert into &OutSet (MRN, CoveredDays, ContinuouslyEnrolled)
4178             select MRN, 0, 0
4179             from _ids
4180             where mrn not in (select mrn from _period_days)
4181             ;
4182          quit ;
4183       
4184       %mend SimpleContinuous3 ;
4185       
4186       %macro GetPxForPeopleAndPx (
4187                                  People  /* The name of a dataset containing the people whose fills you want. */
4188                                  , PxLst   /* The PROC codes of interest */
4189                                  , StartDt /* The date on which you want to start collecting fills.*/
4190                                  , EndDt   /* The date on which you want to stop collecting fills. */
4191                                  , Outset  /* The name of the output dataset containing the fills. */
4192                                  ) ;
4193       
4194          %if &People = &Outset %then %do ;
4195             %put PROBLEM: The People dataset must be different from the OutSet dataset. ;
4196             %put PROBLEM: Both parameters are set to "&People". ;
4197             %put PROBLEM: Doing nothing. ;
4198          %end ;
4199          %else %do ;
4200             libname __u "&_UtilizationLib" access = readonly ;
4201             proc sql ;
4202             create table &OutSet as
4203             			  select d.*
4204             			from  __u.&_pxdata as d
4205             			INNER JOIN &People as p
4206             			on    d.MRN = p.MRN
81                                                         The SAS System                               17:43 Friday, April 16, 2010

4207             			where d.ADate BETWEEN "&StartDt"d AND "&EndDt"d AND
4208             						d.px in (select &PxLst..px from &PxLst) ;
4209             ;
4210             quit ;
4211          %end ;
4212          libname __u clear ;
4213       %mend GetPxForPeopleAndPx ;
4214       
4215       %macro RemoveDset(dset = ) ;
4216          %if %sysfunc(exist(&dset)) %then %do ;
4217             proc sql ;
4218                drop table &dset ;
4219             quit ;
4220          %end ;
4221       %mend RemoveDset ;
4222       
4223       %macro GetKidBMIPercentiles(Inset  /* Dset of MRNs on whom you want kid BMI recs */
4224                               , OutSet
4225                               , StartDt = 01jan1960
4226                               , EndDt = &sysdate9
4227                               ) ;
4228       
4229       
4230          %put ;
4231          %put ;
4232          %put ============================================================== ;
4233          %put ;
4234          %put Macro GetKidBMIPercentiles: ;
4235          %put ;
4236          %put Creating a dataset "&OutSet", which will contain all BMI measures  ;
4237          %put on record for the people whose MRNs are contained in "&InSet" which ;
4238          %put were taken while the people were between the ages of 2 and 17 and ;
4239          %put taken between "&StartDt" and "&EndDt". ;
4240          %put  ;
4241          %put The output dataset will contain a variable calculated by the CDCs ;
4242          %put normative sample percentile score program found here: ;
4243          %put http://www.cdc.gov/nccdphp/dnpao/growthcharts/resources/sas.htm ;
4244          %put ;
4245          %put From this variable (called BMIPCT) you can categorize the children ;
4246          %put into normal/overweight/obese brackets with the following format: ;
4247          %put  ;
4248          %put proc format ;                                                ;
4249          %put    value bmipct                                              ;
4250          %put       low -< 5    = 'Underweight < 5th percentile'           ;
4251          %put       5   -< 85   = 'Normal weight 5th to 84.9th percentile' ;
4252          %put       85  -< 95   = 'Overweight 85th to 94.9th percentile'   ;
4253          %put       95  -  high = 'Obese >=95th percentile'                ;
4254          %put    ;                                                         ;
4255          %put quit ;                                                       ;
4256          %put                                                             ;
4257          %put ============================================================== ;
4258          %put ;
4259          %put ;
82                                                         The SAS System                               17:43 Friday, April 16, 2010

4260       
4261       
4262       
4263          libname __d "&_DemographicLib"   access = readonly ;
4264          libname __v "&_VitalLib"         access = readonly ;
4265       
4266          proc sql ;
4267             * Gather the demog data for our input dset. ;
4268             create table __demog as
4269             select i.mrn
4270                   , case d.gender when 'M' then 1 when 'F' then 2 else . end as sex label = '1 = Male; 2 = Female'
4271                   , d.birth_date
4272             from  &InSet as i LEFT JOIN
4273                   __d.&_DemographicData as d
4274             on    i.mrn = d.mrn
4275             ;
4276       
4277             * Now gather any ht/wt measures that occurred prior to the 18th birthday. ;
4278             create table _indata as
4279             select d.mrn
4280                   , d.sex
4281                   , d.birth_date
4282                   , measure_date
4283                   , ht*2.54         as height label = 'Height in centimeters'
4284                   , wt*0.45359237   as weight label = 'Weight in kilograms'
4285                   , bmi             as original_bmi label = 'BMI as originally calculated'
4286                   , ((measure_date - birth_date)/365.25 * 12) as agemos label = 'Age at measure in months'
4287                   , days_diff
4288                   , %CalcAge(refdate = measure_date) as age_at_measure
4289                   , . as recumbnt   label = 'Recumbent flag (not implemented in VDW)'
4290                   , . as headcir    label = 'Head circumference (not implemented in VDW)'
4291             from  __demog as d INNER JOIN
4292                   __v.&_VitalData as v
4293             on    d.mrn = v.mrn
4294             where calculated age_at_measure between 2 and 17 AND
4295                   ht IS NOT NULL AND
4296                   wt IS NOT NULL AND
4297                   days_diff = 0 AND
4298                   measure_date between "&StartDt"d and "&EndDt"d
4299             ;
4300          quit ;
4301       
4302          * ROY--CHANGE THIS BACK TO PULLING FROM THE FTP SERVER!!! ;
4303         filename kid_bmi   FTP     "gc-calculate-BIV.sas"
4304                            HOST  = "vdw.hmoresearchnetwork.org"
4305                            CD    = "/vdwcode"
4306                            PASS  = "%2hilario36"
4307                            USER  = "VDWReader" ;
4308       
4309       
4310          * filename kid_bmi "\\groups\data\CTRHS\Crn\S D R C\VDW\VitalSigns\gc-calculate-BIV.sas" ;
4311       
4312          data _indata ;
83                                                         The SAS System                               17:43 Friday, April 16, 2010

4313             set _indata ;
4314       
4315          %include kid_bmi ;
4316       
4317          run ;
4318       
4319          data &OutSet ;
4320             set _indata ;
4321       
4322             label
4323                HTPCT    = 'percentile for length-for-age or stature-for-age'
4324                HAZ      = 'z-score for length-for-age or stature-for-age'
4325                WTPCT    = 'percentile for weight-for-age'
4326                WAZ      = 'z-score for weight-for-age'
4327                WHPCT    = 'percentile for weight-for-length or weight-for-stature'
4328                WHZ      = 'z-score for weight-for-length or weight-for-stature'
4329                BMIPCT   = 'percentile for body mass index-for-age'
4330                BMIZ     = 'z-score for body mass index-for-age'
4331                BMI      = 'calculated body mass index value [weight(kg)/height(m)2 ]'
4332                HCPCT    = 'percentile for head circumference-for-age'
4333                HCZ      = 'z-score for head circumference-for-age'
4334                _BIVHT   = 'outlier variable for height-for-age (0  acceptable normal range; 1  too low; 2  too high)'
4335                _BIVWT   = 'outlier variable for weight-for-age (0  acceptable normal range; 1  too low; 2  too high)'
4336                _BIVWHT  = 'outlier variable for weight-for-height (0  acceptable normal range; 1  too low; 2  too high)'
4337                _BIVBMI  = 'outlier variable for body mass index-for-age (0  acceptable normal range; 1  too low; 2  too
4337     ! high)'
4338             ;
4339             %* Note--these are dropped only b/c I dont know what they are--could not find ;
4340             %* documentation on them on the CDC website. ;
4341             drop
4342                _SDLGZLO
4343                _SDLGZHI
4344                _FLAGLG
4345                _SDSTZLO
4346                _SDSTZHI
4347                _FLAGST
4348                _SDWAZLO
4349                _SDWAZHI
4350                _FLAGWT
4351                _SDBMILO
4352                _SDBMIHI
4353                _FLAGBMI
4354                _SDHCZLO
4355                _SDHCZHI
4356                _FLAGHC
4357                _BIVHC
4358                _FLAGWLG
4359                _FLAGWST
4360             ;
4361       
4362          run ;
4363       
4364          libname __d clear ;
84                                                         The SAS System                               17:43 Friday, April 16, 2010

4365          libname __v clear ;
4366       
4367       %mend GetKidBMIPercentiles ;
4368       
4369       %macro GetLabForPeopleAndLab(
4370       							People
4371       						, LabLst
4372       						, StartDt
4373       						, EndDt
4374       						, Outset
4375       						) ;
4376       
4377         *****************************************************************************
4378         Gets the Lab results for a specified set of people (identified by MRNs)
4379         which occurred between the dates specified in StartDt and EndDt.
4380         *****************************************************************************;
4381       
4382         %if &People = &Outset %then %do ;
4383           %put PROBLEM: The People dataset must be different from the OutSet dataset.;
4384           %put PROBLEM: Both parameters are set to "&People". ;
4385           %put PROBLEM: Doing nothing. ;
4386           %end ;
4387         %else %do ;
4388           libname __lab "&_LabLib" access = readonly ;
4389       
4390           proc sql ;
4391             create table __ids as
4392             select distinct mrn
4393             from &people
4394             ;
4395             create table &OutSet as
4396           			select l.*
4397         			from  __lab.&_LabData as l
4398         			INNER JOIN __ids as p
4399         			on    l.MRN = p.MRN
4400         			where l.Lab_dt BETWEEN "&StartDt"d AND "&EndDt"d AND
4401         						l.Test_Type in (select &LabLst..test_type from &LabLst) ;
4402           quit ;
4403           libname __Lab clear ;
4404         %end;
4405       %mend GetLabForPeopleAndLab ;
4406       
4407       %macro make_inclusion_table(cohort = ) ;
4408         libname __d "&_DemographicLib" access = readonly ;
4409         %local demog ;
4410         %let demog = __d.&_DemographicData ;
4411       
4412         proc format ;
4413           value $Hispani
4414             'Y' = '1 Hispanic or Latino'
4415             'N' = '2 Not Hispanic or Latino'
4416             ' '
4417             , ''
85                                                         The SAS System                               17:43 Friday, April 16, 2010

4418             , Missing = '3 Unknown (Individuals not reporting ethnicity)'
4419           ;
4420           value $Gender
4421             'M' = 'Males'
4422             'F' = 'Females'
4423             Other = 'Unknown or Not Reported'
4424           ;
4425       
4426           /*
4427           I would love it if someone could check my geography here--I am especially
4428           unsure of the Native Hawaiian or Other Pac Islander category.
4429           */
4430           value $Race
4431             '01' = '5 White'
4432             '02' = '4 Black or African American'
4433             '03' = '1 American Indian/Alaska Native'
4434             '04'
4435             , '05'
4436             , '06'
4437             , '08'
4438             , '09'
4439             , '10'
4440             , '11'
4441             , '12'
4442             , '13'
4443             , '14'
4444             , '96' = '2 Asian'
4445               '07'
4446             , '20'
4447             , '21'
4448             , '22'
4449             , '25'
4450             , '26'
4451             , '27'
4452             , '28'
4453             , '30'
4454             , '31'
4455             , '32'
4456             , '97' = '3 Native Hawaiian or Other Pacific Islander'
4457               '-1' = '6 More than one race'
4458             Other = '7 Unknown or Not Reported'
4459           ;
4460         quit ;
4461       
4462         * TODO: the macro should check for the presence of gender, race1 and hispanic, and only pull them if necessary. ;
4463         proc sql ;
4464           create table _reportable as
4465           select d.mrn, d.race1 as race label = "Racial Category"
4466                 , d.hispanic label = "Ethnic Category"
4467                 , d.gender label = "Sex/Gender"
4468           from &demog as d INNER JOIN
4469                &cohort as c
4470           on    d.mrn = c.mrn
86                                                         The SAS System                               17:43 Friday, April 16, 2010

4471           ;
4472       
4473           create table genders (gender char(1)) ;
4474           insert into genders(gender) values ('F') ;
4475           insert into genders(gender) values ('M') ;
4476           insert into genders(gender) values ('U') ;
4477       
4478           create table races(race char(2)) ;
4479           insert into races(race) values ('01') ;
4480           insert into races(race) values ('02') ;
4481           insert into races(race) values ('03') ;
4482           insert into races(race) values ('04') ;
4483           insert into races(race) values ('  ') ;
4484           insert into races(race) values ('97') ;
4485           insert into races(race) values ('-1') ;
4486       
4487           create table ethnicities(hispanic char(1)) ;
4488           insert into ethnicities(hispanic) values('Y') ;
4489           insert into ethnicities(hispanic) values('N') ;
4490           insert into ethnicities(hispanic) values(' ') ;
4491       
4492           create table class_levels as
4493           select gender, race, hispanic
4494           from genders CROSS JOIN races CROSS JOIN ethnicities ;
4495       
4496         quit ;
4497       
4498         title1 "Inclusion Enrollment Report" ;
4499       
4500         title2 "PART A TOTAL ENROLLMENT REPORT" ;
4501         proc tabulate data = _reportable missing format = comma15.0 order = formatted classdata = class_levels ;
4502           class hispanic race gender ;
4503           keylabel N = ' ' ;
4504           tables hispanic all='Total of all subjects:', gender all = 'Total' / printmiss misstext = '0' box = 'Ethnic Category'
4504     !  ;
4505           tables race     all='Total of all subjects:', gender all = 'Total' / printmiss misstext = '0' box = 'Racial
4505     ! Categories' ;
4506           format race $race. hispanic $hispani. gender $gender. ;
4507         quit ;
4508       
4509         title2 "PART B HISPANIC ENROLLMENT REPORT" ;
4510         proc tabulate data = _reportable missing format = comma15.0 order = formatted  classdata = class_levels ;
4511           class hispanic race gender ;
4512           keylabel N = ' ' ;
4513           tables race all='Total of Hispanics or Latinos:', gender all = 'Total' / printmiss misstext = '0' box = 'Racial
4513     ! Categories' ;
4514           format race $race. hispanic $hispani. gender $gender. ;
4515           where put(hispanic, $hispani.) = '1 Hispanic or Latino' ;
4516         quit ;
4517       
4518         libname __d clear ;
4519       
4520       %mend make_inclusion_table ;
87                                                         The SAS System                               17:43 Friday, April 16, 2010

4521       

NOTE: SAS Institute Inc., SAS Campus Drive, Cary, NC USA 27513-2414
NOTE: The SAS System used:
      real time           1:04.66
      cpu time            1.22 seconds
      
