1                                                          The SAS System                            11:13 Tuesday, November 8, 2005

NOTE: Unable to open SASUSER.REGSTRY. WORK.REGSTRY will be opened instead.
NOTE: All registry changes will be lost at the end of the session.

NOTE: Copyright (c) 2002-2003 by SAS Institute Inc., Cary, NC, USA. 
NOTE: SAS (r) 9.1 (TS1M3)
      Licensed to GROUP HEALTH COOPERATIVE OF PUGET SOUND, Site 0009688001.
NOTE: This session is executing on the XP_PRO  platform.



NOTE: This installation is running SAS/STAT hot fix bundle SAS 9.1.3 Service Pack 2.

NOTE: SAS initialization used:
      real time           2.14 seconds
      cpu time            0.41 seconds
      
1          /*********************************************
2          * Roy Pardee
3          * Center For Health Studies
4          * (206) 287-2078
5          * pardee.r@ghc.org
6          *
7          * \\groups\data\CTRHS\Crn\S D R C\VDW\Macros\InvestigatePullContinuous2.sas
8          *
9          * <<purpose>>
10         *********************************************/
11         
12         /* This is managed in the login script so that it doesnt
13            actually try to login when the machine is not connected
14            to the network */
15         %include "\\home\pardre1\SAS\Scripts\dw_login.sas" ;
NOTE: PROCEDURE SQL used (Total process time):
      real time           0.00 seconds
      cpu time            0.01 seconds
      

NOTE: Remote signon to CHSDWSAS commencing (SAS Release 9.01.01M3P072804).
NOTE: Script file 'tcpwin.scr' entered.
NOTE: Logged onto Windows... Starting remote SAS now.
NOTE: SAS/CONNECT conversation established.
NOTE: Unable to open SASUSER.PROFILE. WORK.PROFILE will be opened instead.
NOTE: All profile changes will be lost at the end of the session.
NOTE: Copyright (c) 2002-2003 by SAS Institute Inc., Cary, NC, USA. 
NOTE: SAS (r) 9.1 (TS1M3)
      Licensed to GROUP HEALTH COOPERATIVE OF PUGET SOUND, Site 0009688002.
NOTE: This session is executing on the NET_SRV  platform.



NOTE: SAS 9.1.3 Service Pack 2

NOTE: SAS initialization used:
      real time           8.17 seconds
      cpu time            0.31 seconds
      
NOTE: Remote signon to CHSDWSAS complete.
2                                        The SAS System          11:13 Tuesday, November 8, 2005

NOTE: Remote submit to CHSDWSAS commencing.
1    ***********************;
2    * Set the typical libnames... ;
3    %let DWROOT = \\ctrhs-sas\warehouse\SasData\ ;
4    libname consumer  "&DWROOT.Consumer" ;
NOTE: Libref CONSUMER was successfully assigned as follows: 
      Engine:        V9 
      Physical Name: \\ctrhs-sas\warehouse\SasData\Consumer
5    libname chsid     "&DWROOT.CHSID" ;
NOTE: Libref CHSID was successfully assigned as follows: 
      Engine:        V9 
      Physical Name: \\ctrhs-sas\warehouse\SasData\CHSID
6    libname demogs    "&DWROOT.Consumer Demographics" ;
NOTE: Libref DEMOGS was successfully assigned as follows: 
      Engine:        V9 
      Physical Name: \\ctrhs-sas\warehouse\SasData\Consumer Demographics
7    libname enroll    "&DWROOT.Enrollment" ;
NOTE: Libref ENROLL was successfully assigned as follows: 
      Engine:        V9 
      Physical Name: \\ctrhs-sas\warehouse\SasData\Enrollment
8    libname nac       "&DWROOT.Cancer\Naaccr" ;
NOTE: Libref NAC was successfully assigned as follows: 
      Engine:        V9 
      Physical Name: \\ctrhs-sas\warehouse\SasData\Cancer\Naaccr
9    libname naaccr    "&DWROOT.Cancer\Naaccr" ;
NOTE: Libname NAACCR refers to the same physical library as NAC.
NOTE: Libref NAACCR was successfully assigned as follows: 
      Engine:        V9 
      Physical Name: \\ctrhs-sas\warehouse\SasData\Cancer\Naaccr
10   libname baseline  "&DWROOT.Baseline" ;
NOTE: Libref BASELINE was successfully assigned as follows: 
      Engine:        V9 
      Physical Name: \\ctrhs-sas\warehouse\SasData\Baseline
11   libname arpa      "&DWROOT.arpa" ;
NOTE: Libref ARPA was successfully assigned as follows: 
      Engine:        V9 
3                                        The SAS System          11:13 Tuesday, November 8, 2005

      Physical Name: \\ctrhs-sas\warehouse\SasData\arpa
12   libname mbhist    "&DWROOT.mbhist" ;
NOTE: Libref MBHIST was successfully assigned as follows: 
      Engine:        V9 
      Physical Name: \\ctrhs-sas\warehouse\SasData\mbhist
13   libname mbcurr    "&DWROOT.mbcurr" ;
NOTE: Libref MBCURR was successfully assigned as follows: 
      Engine:        V9 
      Physical Name: \\ctrhs-sas\warehouse\SasData\mbcurr
14   libname claims    "&DWROOT.claims" ;
NOTE: Libref CLAIMS was successfully assigned as follows: 
      Engine:        V9 
      Physical Name: \\ctrhs-sas\warehouse\SasData\claims
15   libname death     "&DWROOT.death" ;
NOTE: Libref DEATH was successfully assigned as follows: 
      Engine:        V9 
      Physical Name: \\ctrhs-sas\warehouse\SasData\death
16   libname hosp      "&DWROOT.Hospital" ;
NOTE: Libref HOSP was successfully assigned as follows: 
      Engine:        V9 
      Physical Name: \\ctrhs-sas\warehouse\SasData\Hospital
17   libname VDW       "&DWROOT.CRN_VDW" ;
NOTE: Libref VDW was successfully assigned as follows: 
      Engine:        V9 
      Physical Name: \\ctrhs-sas\warehouse\SasData\CRN_VDW
18   
19   footnote "Program file: &CurrFile " ;
20   
21   
22   options linesize = 150 nocenter msglevel = i NOOVP formchar='|-++++++++++=|-/|<>*' ;
23   
24   libname s "\\CTRHS-SAS\SASUser\pardre1" ;
NOTE: Libref S was successfully assigned as follows: 
      Engine:        V9 
      Physical Name: \\CTRHS-SAS\SASUser\pardre1
25   
26   %include "\\groups\data\CTRHS\Crn\S D R C\VDW\Macros\StdVars.sas" ;
81   
82   %include "\\groups\data\CTRHS\Crn\S D R C\VDW\Macros\CRN_VDW_MACROS.sas" ;
1553  
1554  /*
1555  
1556     These 2 calls do not currently give the same results, and they should.
1557  
1558  %PullContinuous2(InSet                   = possibles
1559                 , OutSet                  = test.enrolled
1560                 , IndexDate               = '01Jul2003'd
1561                 , PreIndexEnrolledMonths  = 0
1562                 , PreIndexGapTolerance    = 0
1563                 , PostIndexEnrolledMonths = 24
1564                 , PostIndexGapTolerance   = 2
1565                 ) ;
1566  
4                                        The SAS System          11:13 Tuesday, November 8, 2005

1567  %PullContinuous2(InSet                   = possibles
1568                 , OutSet                  = test.enrolled
1569                 , IndexDate               = '01Jul2003'd
1570                 , PreIndexEnrolledMonths  = 0
1571                 , PreIndexGapTolerance    = 1000
1572                 , PostIndexEnrolledMonths = 24
1573                 , PostIndexGapTolerance   = 2
1574                 ) ;
1575  
1576  */
1577  
1578  
1579  
1580  
1581  /*
1582  %PullContinuous2(InSet                   = s.possibles
1583                 , OutSet                  = s.new_pc2_results
1584                 , IndexDate               = '01Jul2003'd
1585                 , PreIndexEnrolledMonths  = 0
1586                 , PreIndexGapTolerance    = 0
1587                 , PostIndexEnrolledMonths = 24
1588                 , PostIndexGapTolerance   = 2
1589                 ) ;
1590  
1591  
1592  The last version of the code returned 399,997 people.
1593  This new version returns              407,282 people.
1594  
1595  Everyone who made through the old version is also in the new version.
1596  
1597  So drill-down on the newbies--do they deserve to be here?
1598  
1599  NO--looks like these are all ppl w/periods prior to index date,
1600  which periods end exactly one month after the index date.
1601  
1602  So--add a test case to TestPullContinuous2.sas & see if I can
1603  get it to fail.  Done--fails.  Fixed--and no new failures.  So run
1604  on the whole group again.
1605  
1606  Done--and now we get the same 399,997 people from both runs.
1607  */
1608  
1609  proc sql ;
1610     create table s.unique_to_new as
1611     select n.mrn
1612     from  s.new_pc2_results as n LEFT JOIN
1613           s.old_pc2_results as o
1614     on    n.mrn = o.mrn
1615     where o.mrn IS NULL ;
NOTE: SAS threaded sort was used.
NOTE: Table S.UNIQUE_TO_NEW created, with 0 rows and 1 columns.

1616  
5                                        The SAS System          11:13 Tuesday, November 8, 2005

1617     create table s.unique_to_old as
1618     select o.MRN
1619     from s.old_pc2_results as o LEFT JOIN
1620           s.new_pc2_results as n
1621     on    o.mrn = n.mrn
1622     where n.mrn IS NULL ;
NOTE: SAS threaded sort was used.
NOTE: Table S.UNIQUE_TO_OLD created, with 0 rows and 1 columns.

1623  quit ;
NOTE: PROCEDURE SQL used (Total process time):
      real time           5.52 seconds
      cpu time            4.90 seconds
      

1624  
1625  /*
1626  proc sql outobs = 10 nowarn ;
1627     create table testies as
1628     select mrn
1629     from s.unique_to_new
1630     order by uniform(123) ;
1631  
1632     reset outobs = max ;
1633  
1634     create table s.raw_enroll as
1635     select e.mrn
1636           , mdy(enr_month, 1, enr_year) as enrdate format = mmddyy10.
1637           , '01Jul2003'd as IndexDate format = mmddyy10.
1638           , intck('MONTH', calculated IndexDate, calculated EnrDate) as MonthNum
1639     from vdw.enroll as e INNER JOIN
1640           testies as t
1641     on    e.mrn = t.mrn
1642     where e.enr_year between 2003 and 2005
1643     order by mrn, enr_year, enr_month
1644     ;
1645  
1646  quit ;
1647  
1648  */
1649  
1650  
1651  /*
1652  proc sql ;
1653     create table s.possibles as
1654     select distinct MRN
1655     from vdw.enroll
1656     where enr_year ge 2003
1657     ;
1658  quit ;
1659  %PullContinuous2(InSet                   = s.possibles
1660                 , OutSet                  = s.normal
1661                 , IndexDate               = '01Jul2003'd
6                                        The SAS System          11:13 Tuesday, November 8, 2005

1662                 , PreIndexEnrolledMonths  = 0
1663                 , PreIndexGapTolerance    = 0
1664                 , PostIndexEnrolledMonths = 24
1665                 , PostIndexGapTolerance   = 2
1666                 ) ;
1667  
1668  %PullContinuous2(InSet                   = s.possibles
1669                 , OutSet                  = s.weird
1670                 , IndexDate               = '01Jul2003'd
1671                 , PreIndexEnrolledMonths  = 0
1672                 , PreIndexGapTolerance    = 1000
1673                 , PostIndexEnrolledMonths = 24
1674                 , PostIndexGapTolerance   = 2
1675                 ) ;
1676  
1677  proc sql ;
1678     create table s.in_normal_but_not_weird as
1679     select n.*
1680     from  s.normal as n LEFT JOIN
1681           s.weird as w
1682     on    n.MRN = w.MRN
1683     where w.MRN IS NULL
1684     ;
1685  
1686     reset exec ;
1687  
1688     create table s.in_weird_but_not_normal as
1689     select w.*
1690     from  s.normal as n RIGHT JOIN
1691           s.weird as w
1692     on    n.MRN = w.MRN
1693     where n.MRN IS NULL
1694     ;
1695  quit ;
1696  
1697  /*
1698  
1699     The pregap = 1000 run gives 456,600 people
1700     The pregap = 0    run gives 407,763 people
1701     There are 50,724 people in 1000 that don't also appear in 0.
1702     There are 1,887  people in 0    that don't also appear in 1000.
1703  
1704  
1705  * Step 1--look at the smaller group. ;
1706  proc sql ;
1707  
1708     reset noexec ;
1709  
1710     delete from s.in_normal_but_not_weird
1711     where MRN not in (select MRN from s.normal_rejects)
1712     ;
1713  
1714     create table s.nnw_raw as
7                                        The SAS System          11:13 Tuesday, November 8, 2005

1715     select e.MRN
1716           , mdy(enr_month, 1, enr_year) as EnrDate format = mmddyy10.
1717           , '01Jul2003'd as IndexDate format = mmddyy10.
1718           , intck('MONTH', calculated IndexDate, calculated EnrDate) as MonthNum
1719     from  s.in_normal_but_not_weird as t INNER JOIN
1720           vdw.enroll as e
1721     on    e.MRN = t.MRN
1722     where calculated enrdate ge calculated indexdate AND
1723           calculated MonthNum le 24
1724     order by e.MRN, e.enr_year, e.enr_month
1725     ;
1726  
1727     * reset exec ;
1728  
1729     create table s.nnw_counts as
1730     select mrn, count(*) as num_months
1731     from s.nnw_raw
1732     group by mrn
1733     order by 2 desc
1734     ;
1735  
1736     select num_months, count(*) as freq
1737     from s.nnw_counts
1738     group by num_months ;
1739  
1740  */
1741  
1742     /*
1743  
1744        This gives:
1745  
1746        num_months      freq
1747        --------------------
1748                24       687
1749                23       810
1750                22       113
1751                21        49
1752                20        10
1753  
1754  
1755     */
1756  
1757  
1758  /*
1759     create table s.drop_me as
1760     select r.*
1761     from s.nnw_raw as r INNER JOIN
1762           s.nnw_counts as c
1763     on    r.mrn = c.mrn
1764     where c.num_months le 21
1765     order by r.mrn, r.enrdate
1766     ;
1767  
8                                        The SAS System          11:13 Tuesday, November 8, 2005

1768  quit ;
1769  
1770  data s.drop_me ;
1771     retain _lastdate . ;
1772     set s.drop_me ;
1773     by mrn enrdate ;
1774  
1775     if first.mrn then do ;
1776        gap = 0 ;
1777     end ;
1778     else do ;
1779        gap = intck("MONTH", _LastDate, enrdate) ;
1780     end ;
1781  
1782     _lastdate = enrdate ;
1783     format _lastdate mmddyy10. ;
1784  run ;
1785  
1786  /*
1787     Theory: There is an order effect happening, whereby depending on where a persons data 
lie
1788     in the input dset (or in ENROLL) allows some of the data to be missed.
1789  
1790     DISPROVED!  All the same MRNs come through a second time.
1791  
1792     New Theory: the problem is particular to recs where there is only a single record 
during the period of interest.
1793  
1794     Yes--thats it.  I test for first.mrn and last.mrn in a SELECT block, the nature of 
which is to execute the first branch
1795     that tests true, and *only* that branch.  For these recs first.mrn is true, and so the 
ThisGap var is the gap between
1796     this rec and the start of the period of interest.  But the last.mrn branch is never 
traveled, and so EndGap is
1797     not getting set properly.
1798  
1799  data gnu ;
1800     set s.nnw_counts ;
1801     * where num_months = 1 ;
1802     keep mrn ;
1803  run ;
1804  
1805  %PullContinuous2(InSet                   = gnu
1806                 , OutSet                  = s.normal_rejects
1807                 , IndexDate               = '01Jul2003'd
1808                 , PreIndexEnrolledMonths  = 0
1809                 , PreIndexGapTolerance    = 0
1810                 , PostIndexEnrolledMonths = 24
1811                 , PostIndexGapTolerance   = 2
1812                 ) ;
1813  
1814  run ;
1815  */
9                                        The SAS System          11:13 Tuesday, November 8, 2005

1816  
1817  /*
1818  
1819  
1820  *Step 2: Look at the larger group. ;
1821  proc sql noexec ;
1822  
1823     reset outobs = 10 nowarn ;
1824  
1825     create table test as
1826     select mrn, uniform(0)
1827     from   s.in_weird_but_not_normal
1828     ;
1829  
1830     reset outobs = max ;
1831  
1832     create table s.wnn_raw as
1833     select e.MRN
1834           , mdy(enr_month, 1, enr_year) as EnrDate format = mmddyy10.
1835           , '01Jul2003'd as IndexDate format = mmddyy10.
1836           , intck('MONTH', calculated IndexDate, calculated EnrDate) as MonthNum
1837     from  test as t INNER JOIN
1838           vdw.enroll as e
1839     on    e.MRN = t.MRN
1840     order by e.MRN, e.enr_year, e.enr_month
1841     ;
1842  
1843  */
1844  /*
1845  
1846     Okay, the pattern seems to be that people w/large pre-index
1847     gaps and *no* post-index enrollment are getting in.  Lets re-run
1848     on a small group and see what the log looks like.
1849  
1850     And the operative problem is that gaps that cross the index are evaluated as pre-index
1851     gaps.  "This is just an arbitrary decision", say the comments in the program.
1852  
1853     The quick fix is to validate the macro parameter values to disallow gap tolerances
1854     greater than the desired number of enrolled months.  That will almost surely fix this
1855     problem.
1856  
1857  
1858     Okay--tried that--it does indeed fix the problem.  But do we want to elaborate the 
macro
1859     so that it evals the pre- and post- parts of the gap independantly?  That would 
probably
1860     be more in line w/user expectations.
1861  
1862     reset exec ;
1863  
1864     create table test as
1865     select distinct mrn
1866     from s.wnn_raw
10                                       The SAS System          11:13 Tuesday, November 8, 2005

1867     ;
1868  
1869  quit ;
1870  
1871  %PullContinuous2(InSet                   = test
1872                 , OutSet                  = s.weird_rejects
1873                 , IndexDate               = '01Jul2003'd
1874                 , PreIndexEnrolledMonths  = 0
1875                 , PreIndexGapTolerance    = 1000
1876                 , PostIndexEnrolledMonths = 24
1877                 , PostIndexGapTolerance   = 2
1878                 ) ;
1879  
1880  */
NOTE: Remote submit to CHSDWSAS complete.
NOTE: SAS Institute Inc., SAS Campus Drive, Cary, NC USA 27513-2414
NOTE: The SAS System used:
      real time           23.64 seconds
      cpu time            0.93 seconds
      
